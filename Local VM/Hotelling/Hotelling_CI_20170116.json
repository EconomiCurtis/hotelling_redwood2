[{"fields": {"name": "Experiment 1", "admin_css": "body {\r\n  padding-top: 60px;\r\n}\r\n\r\n.no-margin {\r\n  margin: 0px;\r\n}", "comments": "Port of Hotelling Circle to Redwood2\r\n\r\nwork in progress.\r\n\r\nTODO:\r\n\r\n\r\n5/17:\r\n     Initial port of circle marketplace looks good. I'm still doing some debugging on weirdness that didn't port over correctly.\r\n5/22:\r\n     Fixed some weird synchronization issues that caused payoffs to be calculated differently for each player\r\n2016 10/25:\r\n     Simon: clock was not being instantiated properly due to async send/recv of configuration. Manually initialized few variables from the config file to solve the problem.\r\n     New problem. r is not defined. It is commented as \"Redwood\". WHICH ONE??!?!?!!\r\n11.10: \r\n     Simon: fixed two major bugs: timewatch, plot update\r\n     to do: implement silo function, display payoff summary, refresh-data corruption bug\r\n12/09:\r\n     Simon: implemented siloing and fixed summary page bug\r\n2017 January\r\n     Simon: display better looking", "experimenter": 1, "admin_html": "<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n  <head>\r\n\t\t<title>Hotelling Admin</title>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodAdmin.js\"></script>\r\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\">\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n\t<body ng-controller=\"AdminCtrl\">\r\n\t\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n\t\t\t<div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n\t\t\t\t<div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n\t\t\t\t<ul class=\"nav navbar-nav\">\r\n\t\t\t\t\t<li class=\"active\">\r\n\t\t\t\t\t\t<a>Administrator</a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t\r\n\t\t<div class=\"container\">\r\n\r\n\t\t\t<div class=\"row\">\r\n\t\t\t\t<div class=\"col-md-3\">\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"col-md-12\">\r\n\t\t\t\t\t\t\t<div id=\"router-status\" class=\"alert alert-danger\"></div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"col-md-12\">\r\n\t\t\t\t\t\t\t<div class=\"panel panel-default\">\r\n\t\t\t\t\t\t\t\t<div class=\"panel-body\">\r\n\t\t\t\t\t\t\t\t\t<ul class=\"nav nav-pills nav-stacked\">\r\n\t\t\t\t\t\t\t\t\t\t<li><a href=\"admin/payouts\" target=\"_blank\">View Payouts</a></li>\r\n\t\t\t\t\t\t\t\t\t\t<li><a id=\"archive\" href=\"#\">Archive Session</a></li>\r\n\t\t\t\t\t\t\t\t\t\t<li><a id=\"download\" href=\"admin/download\">Download Data</a></li>\r\n\t\t\t\t\t\t\t\t\t</ul>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div class=\"col-md-9\">\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"col-md-12\">\r\n\t\t\t\t\t\t\t<h4>Subjects</h4>\r\n\t\t\t\t\t\t\t<table class=\"table table-bordered table-condensed table-striped\">\r\n\t\t\t\t\t\t\t\t<thead>\r\n\t\t\t\t\t\t\t\t<tr><th>ID</th><th>Group</th><th>Period</th><th style=\"width: 150px;\"></th></tr>\r\n\t\t\t\t\t\t\t\t</thead>\r\n\t\t\t\t\t\t\t\t<tbody id=\"subject-list\">\r\n\t\t\t\t\t\t\t\t</tbody>\r\n\t\t\t\t\t\t\t</table>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div class=\"row\">\r\n\t\t\t\t\t\t<div class=\"col-md-8\">\r\n\t\t\t\t\t\t\t<button id=\"start-session\" class=\"btn btn-success\">Start Session</button>\r\n\t\t\t\t\t\t\t<button id=\"refresh-subjects\" class=\"btn btn-info\" title=\"Attempt recover by refreshing all subject browsers\">Recover Session</button>\r\n\t\t\t\t\t\t\t<button id=\"reset-session\" class=\"btn btn-danger\">Reset Session</button>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t<div class=\"col-md-4\">\r\n\t\t\t\t\t\t\t<div class=\"pull-right\">\r\n\t\t\t\t\t\t\t\t<button id=\"pause-session\" class=\"btn btn-warning\" disabled=\"disabled\">Pause</button>\r\n\t\t\t\t\t\t\t\t<button id=\"resume-session\" class=\"btn btn-primary\" disabled=\"disabled\">Resume</button>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t\t<hr>\r\n\t\t\t<div class='row no-margin'>\r\n\t\t\t\t<div class=\"col-md-6\">\r\n\t\t\t\t\t<div class=\"well\">\r\n\t\t\t\t\t\t<input id=\"silo_size\" type=\"integer\" value=\"\" placeholder=\"Silo sz\" style=\"text-align: left; width:4em;\"><span id=\"silo_size\"></span>\r\n\t\t              \t<button type=\"button\" class=\"btn btn-primary\" id=\"set_silo_size\">Set Silo Sizes</button>\r\n\t\t              \t\r\n\t\t              \t<hr>\r\n\r\n\t\t              \t<input id=\"group_size\" type=\"integer\" value=\"\" placeholder=\"Groups\" style=\"text-align: left; width:4em;\"><span id=\"group_size\"></span>\r\n\t\t              \t<button type=\"button\" class=\"btn btn-primary\" id=\"set_group_size\">Set Group Size</button>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div class=\"col-md-6\">\r\n\t\t\t\t\t<div class=\"well\">\r\n\t\t\t\t\t\t<div id=\"current_group\"></div>\r\n\t\t              \t\r\n\t\t              \t<hr>\r\n\r\n\t\t              \t<div id='current_silo'></div>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t    </div>\r\n\t\t\t<div class=\"row\">\r\n\t\t\t\t<div class=\"col-md-12\">\r\n\t\t\t\t\t<h4>Configuration</h4>\r\n\t\t\t\t\t<load-config></load-config>\r\n\t\t\t\t\t<div style=\"overflow: auto;\">\r\n\t\t\t\t\t\t<table class=\"config table table-bordered table-striped table-condensed\"></table>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</body>\r\n\r\n</html>\r\n", "admin_js": "Redwood.controller(\"AdminCtrl\", [\"$rootScope\", \"$scope\", \"Admin\", function($rootScope, $scope, ra) {\r\n    var new_period = 2;\r\n    var group_size = 2;\r\n    var silo_size = 1;\r\n    var silos = [ //array of silos. must be coherent with groups\r\n        [],\r\n        [],\r\n        [],\r\n        [],\r\n        [],\r\n        [],\r\n        [],\r\n        [],\r\n        [],\r\n        [],\r\n        [],\r\n        []\r\n    ];\r\n    var subject_count = 0;\r\n    var per_period_subject_counter = {};\r\n    var subjs = [];\r\n    var groups = []; //array of groups. must be coherent with silos\r\n    $('#current_silo').html('<small>Current Silo Size: ' + silo_size + '</small>');\r\n    $('#current_group').html('<small>Current Group Size: ' + group_size + '</small>');\r\n\r\n    var Display = {}; //display controller\r\n    Display.initialize = function() {\r\n\r\n        $(\"#start-session\").click(function() {\r\n            $(\"#start-session\").attr(\"disabled\", \"disabled\");\r\n            ra.trigger(\"start_session\");\r\n        });\r\n\r\n        ra.on(\"start_session\", function() {\r\n            $(\"#start-session\").attr(\"disabled\", \"disabled\");\r\n            $(\"#pause-session\").removeAttr(\"disabled\");\r\n        });\r\n\r\n        $(\"#refresh-subjects\").click(function() {\r\n            $(\"#refresh-subjects\").attr(\"disabled\", \"disabled\");\r\n            ra.refreshSubjects().then(function() {\r\n                $(\"#refresh-subjects\").removeAttr(\"disabled\");\r\n            });\r\n        });\r\n\r\n        $(\"#reset-session\").click(function() {\r\n            ra.reset();\r\n        });\r\n\r\n        $(\"#pause-session\").click(function() {\r\n            $(\"#pause-session\").attr(\"disabled\", \"disabled\");\r\n            ra.trigger(\"pause\");\r\n        });\r\n        ra.on(\"pause\", function() {\r\n            $(\"#pause-session\").attr(\"disabled\", \"disabled\");\r\n        });\r\n\r\n        $(\"#resume-session\").click(function() {\r\n            $(\"#resume-session\").attr(\"disabled\", \"disabled\");\r\n            ra.trigger(\"resume\");\r\n        });\r\n        ra.on(\"resume\", function() {\r\n            $(\"#resume-session\").attr(\"disabled\", \"disabled\");\r\n            $(\"#pause-session\").removeAttr(\"disabled\");\r\n        });\r\n\r\n        ra.on_subject_paused(function(userId) {\r\n            $(\"#pause-session\").attr(\"disabled\", \"disabled\");\r\n            $(\"tr.subject-\" + userId).addClass(\"warning\"); //Display current period for each user\r\n            $(\"tr.subject-\" + userId + \" :nth-child(4)\").text(\"Paused\"); //Display current period for each user\r\n        });\r\n\r\n        ra.on_all_paused(function() {\r\n            $(\"#resume-session\").removeAttr(\"disabled\");\r\n        });\r\n\r\n        ra.on_subject_resumed(function(user) {\r\n            $(\"tr.subject-\" + user).removeClass(\"warning\"); //Display current period for each user\r\n            $(\"tr.subject-\" + user + \" :nth-child(4)\").text(\"\"); //Display current period for each user\r\n        });\r\n\r\n        $(\"#archive\").click(function() {\r\n            var r = confirm(\"Are you sure you want to archive this session?\");\r\n            if (r == true) {\r\n                ra.delete_session();\r\n            }\r\n        });\r\n\r\n        ra.on_router_connected(function(connected) { //Display router connection status\r\n  \t\t\t\tvar status = $(\"#router-status\");\r\n  \t\t\t\tif (connected) {\r\n  \t\t\t\t\tstatus.text(\"Router Connected\");\r\n  \t\t\t\t\tstatus.removeClass(\"alert-danger\");\r\n  \t\t\t\t\tstatus.addClass(\"alert-success\");\r\n  \t\t\t\t} else {\r\n  \t\t\t\t\tstatus.text(\"Router Disconnected\");\r\n  \t\t\t\t\tstatus.removeClass(\"alert-success\");\r\n  \t\t\t\t\tstatus.addClass(\"alert-danger\");\r\n  \t\t\t\t}\r\n  \t\t\t});\r\n\r\n        ra.on_set_period(function(user, period) {\r\n            $(\"tr.subject-\" + user + \" :nth-child(3)\").text(period); //Display current period for each user\r\n        });\r\n\r\n        ra.on_set_group(function(user, group) {\r\n            $(\"tr.subject-\" + user + \" :nth-child(2)\").text(group); //Display group for each user\r\n        });\r\n\r\n        ra.on_register(function(user) { //Add a row to the table to each user\r\n            $(\"#subject-list\").empty();\r\n            for (var i = 0, l = ra.subjects.length; i < l; i++) {\r\n                $(\"#subject-list\").append($(\"<tr>\").addClass(\"subject-\" + ra.subjects[i].user_id).append(\r\n                    $(\"<td>\").text(ra.subjects[i].user_id).after(\r\n                        $(\"<td>\").text(0).after(\r\n                            $(\"<td>\").text(0).after(\r\n                                $(\"<td>\").text(\"\"))))));\r\n            }\r\n        });\r\n\r\n\r\n\r\n        $(\"#set_period\").click(function() {\r\n            if (new_period !== 0 && new_period !== undefined && new_period !== null && ra.subjects.length > 0) {\r\n                for (var i = 0, l = ra.subjects.length; i < l; i++) {\r\n                    ra.set_period(new_period, ra.subjects[i].user_id);\r\n                }\r\n                ++new_period;\r\n            }\r\n            $(\"#set_period\").html(\"Start Period: \" + new_period);\r\n        });\r\n\r\n\r\n\r\n\r\n        $(\"#set_group_size\").click(function() {\r\n            tmp = Number(document.getElementById('group_size').value);\r\n\r\n            if (tmp > 0 && tmp !== undefined && tmp !== null && !isNaN(tmp) && (silo_size % tmp == 0)) {\r\n                group_size = tmp;\r\n                ra.trigger(\"assign_group\");\r\n            }\r\n            else {\r\n                alert('Please make sure silo size is a multiple of group size');\r\n            }\r\n            $('#current_group').html('<small>Current Group Size: ' + group_size + '</small>');\r\n        });\r\n\r\n        //assigns subjects to new groups within their silo\r\n        ra.on(\"assign_group\", function(msg) {\r\n            console.log(\"msg\", msg);\r\n            setGroups = true;\r\n            subject_count = 0; //we'll count subjects again\r\n            var silosCopy = clone(silos); //we don't want to alter original data of silos\r\n            var groups = [];\r\n            //dedim(silosCopy) flattens the array into 1D array, in effect returning an array of subjects\r\n            console.log(\"silosCopy\", silosCopy);\r\n            console.log(\"dedim(silosCopy)\", dedim(silosCopy));\r\n            console.log(\"group_size\", group_size);\r\n            var numberOfGroups = Math.ceil(dedim(silosCopy).length / group_size); \r\n            console.log(\"numberOfGroups\", numberOfGroups);\r\n            for (var i = 0; i < numberOfGroups; i++) {\r\n                groups.push([]);\r\n            }\r\n            console.log(groups, \"groups\");\r\n\r\n            //go through array of silos and groups simultaneously (tracked by curr_silo, curr_group)\r\n            //take a random subject from each silo and put it into the group.\r\n            for (var curr_silo = 0, curr_group = 0, l = silosCopy.length; curr_silo < l; curr_silo++) {\r\n                var silo = silosCopy[curr_silo];\r\n                // console.log(groups, \"groups\");\r\n                var group = groups[curr_group];\r\n                while (silo.length !== 0) {\r\n                    // console.log(\"curr_silo, curr_group \", curr_silo, curr_group);\r\n                    if (group.length >= group_size) group = groups[++curr_group]; //if group is full, go onto next group\r\n                    var rand = Math.floor(Math.random() * (silo.length)); \r\n                    var randomSubject = silo.splice(rand, 1)[0];                  //selects one random subject from currrent silo\r\n                    console.log(\"!msg.current_period\", !msg || !msg.current_period);\r\n                    ra.set_group(curr_group + 1, randomSubject.user_id);          //tell server to set subject's group number. if it's before game starts, do the normal protocol. else, only change group number\r\n                    group.push(randomSubject);                                    //push to group. increments group.length\r\n                    subject_count++;\r\n                }\r\n            }\r\n        });\r\n\r\n\r\n        function custom_set_group(group_id, user_id) {\r\n            ra.sendCustom(\"custom_set_group\", { user_id : user_id , group_id : group_id });\r\n\r\n        }\r\n\r\n\r\n\r\n        $(\"#set_silo_size\").click(function() {\r\n            tmp = Number(document.getElementById('silo_size').value);\r\n            if (tmp > 0 && tmp !== undefined && tmp !== null && !isNaN(tmp) && tmp <= ra.subjects.length) {\r\n                silo_size = tmp;\r\n                ra.trigger(\"assign_silo\");\r\n            } else {\r\n                alert('Please make sure the silo size is less than or equal to the number of subjects');\r\n            }\r\n            $('#current_silo').html('<small>Current Silo Size: ' + silo_size + '</small>');\r\n        });\r\n        ra.on(\"assign_silo\", function() {\r\n\r\n            tmp = Number(document.getElementById('silo_size').value);\r\n\r\n            if (tmp > 0 && tmp !== undefined && tmp !== null && !isNaN(tmp) && tmp <= ra.subjects.length) {\r\n                silo_size = tmp; //already set when pressed the button but let's do it again\r\n            }\r\n            subjs = [];\r\n            silos = [];\r\n\r\n            /**\r\n             * collect all subjects into subjs\r\n             * [Simon] Previous version of this code used for .. in loop.\r\n             * for .. in should be avoided in arrays because it also looks at prototype elements\r\n             */\r\n            for (var i = ra.subjects.length - 1; i >= 0; i--) {\r\n                var subj = {};\r\n                subj.user_id = ra.subjects[i].user_id;\r\n                subj.silo = -1;\r\n                subjs.push(subj);\r\n            }\r\n\r\n            /**\r\n             * number of subjects should be divisible by silo_size. If not, unpredictable behaviour may occur.\r\n             * create exact number of silos needed (numberOfSilos)\r\n             */\r\n            var numberOfSilos = Math.ceil(subjs.length / silo_size);\r\n            for (var i = 0; i < numberOfSilos; i++) {\r\n                silos.push([]);\r\n            }\r\n\r\n            /**\r\n             * go through each silo. while silo is not full and subject available\r\n             * radomly select a subject, remove it from subjs list and push into silo\r\n             * assumes that we have the correct number of silos\r\n             */\r\n            for (var i = silos.length - 1; i >= 0; i--) {\r\n                var silo = silos[i];\r\n                var siloIndex = i + 1;\r\n                while (silo.length !== silo_size && subjs.length !== 0) {\r\n                    var rand = Math.floor(Math.random() * subjs.length);\r\n                    var randomSubject = subjs.splice(rand, 1)[0]; //selects one random subject\r\n                    randomSubject.silo = siloIndex;\r\n                    silo.push(randomSubject);\r\n                }\r\n            }\r\n\r\n            console.log('success setting silos. silo_size = ', silo_size);\r\n            console.log(\"silos \", silos);\r\n        });\r\n\r\n\r\n\r\n\r\n        ra.on_set_config(function(config) { //Display the config file\r\n            $(\"table.config\").empty();\r\n            var a = $.csv.toArrays(config);\r\n            for (var i = 0; i < a.length; i++) {\r\n                var row = a[i];\r\n                var tr = $(\"<tr>\");\r\n                for (var j = 0; j < row.length; j++) {\r\n                    var cell = row[j];\r\n                    var td = $((i === 0 ? \"<th>\" : \"<td>\")).text(cell);\r\n                    tr.append(td);\r\n                }\r\n                $(\"table.config\").append(tr);\r\n            }\r\n        });\r\n    };\r\n\r\n    var resetGroups = function() {\r\n        var config = ra.get_config(1, 0) || {};\r\n        //set all subjects to group 1 \r\n        //(this is so that matching can be changed per period)\r\n        for (var i = 0; i < ra.subjects.length; i++) { \r\n            if ($.isArray(config.groups)) {\r\n                for (var groupId = 0; groupId < config.groups.length; groupId++) {\r\n                    if ($.isArray(config.groups[groupId])) {\r\n                        if (config.groups[groupId].indexOf(parseInt(ra.subjects[i].user_id)) > -1) { //Nested group array\r\n                            ra.set_group(groupId + 1, ra.subjects[i].user_id);\r\n                        }\r\n                    } else {\r\n                        ra.set_group(1, ra.subjects[i].user_id);\r\n                    }\r\n                }\r\n            } else {\r\n                ra.set_group(1, ra.subjects[i].user_id);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n\r\n    Display.initialize();\r\n\r\n    ra.on_load(function() {\r\n        resetGroups(); //Assign groups to users\r\n    });\r\n\r\n    ra.on_register(function(user) { //Add a row to the table to each user\r\n        resetGroups();\r\n    });\r\n\r\n    ra.on(\"start_session\", function() {\r\n        ra.start_session();\r\n    });\r\n\r\n    ra.on(\"pause\", function() {\r\n        ra.pause();\r\n    });\r\n\r\n    ra.on(\"resume\", function() {\r\n        ra.resume();\r\n    });\r\n\r\n    ra.recv(\"new_period_request\", function(uid, msg) {\r\n        /*\r\n        counts the number of messages called and if every subject sent this message, trigger assign_group\r\n         */\r\n            var current_period = msg.current_period;\r\n            console.log(\"current_period \", current_period);\r\n            if ( current_period > 0 && current_period !== undefined && current_period !== null && !isNaN(current_period) ) {\r\n                console.log(\"valid msg\");\r\n                if ( !per_period_subject_counter[current_period] ) { //if first subject - period information is not existant\r\n                    console.log(\"first subject has arrived\");\r\n                    per_period_subject_counter[current_period] = subject_count;\r\n                }\r\n                console.log(per_period_subject_counter[current_period]);\r\n                if ( --per_period_subject_counter[current_period] == 0 ) { //if we counted down all subjects\r\n                    console.log(\"last subject has arrived\");\r\n                    ra.trigger(\"assign_group\", {current_period : current_period});\r\n                    ra.sendCustom(\"new_period_called_by_admin\", {current_period : current_period});\r\n                }\r\n            }\r\n        }); \r\n\r\n    /*\r\n     ********************\r\n     * Helper functions *\r\n     ********************\r\n     */\r\n    \r\n    // Dedimensionize a given array\r\n    function dedim(arr) {\r\n        var result = [];\r\n        _dedim(arr, result);\r\n        return result;\r\n    }\r\n    function _dedim(arr, result) {\r\n        if (dataTypeOf(arr) == 'array') {\r\n            var len = arr.length;\r\n            for (var i = 0; i < len; i++) {\r\n                _dedim(arr[i], result);\r\n            }\r\n        }\r\n        else {\r\n            result.push(arr);\r\n        }\r\n    }\r\n    // Function that outputs a more specific data type\r\n    function dataTypeOf(data) {\r\n        return Object.prototype.toString.call(data).slice(8,-1).toLowerCase();\r\n    }\r\n\r\n    // clones an object\r\n    function clone(obj){\r\n        return JSON.parse(JSON.stringify(obj));\r\n    }\r\n\r\n}]);", "rt_js": ""}, "model": "expecon.experiment", "pk": 4}, {"fields": {"experiment": 4, "html": "{% load verbatim %}\r\n<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n\t<head>\r\n\t  {% verbatim %}\r\n\t\t<title>S{{ $root.user_id }} || Wait</title>\r\n\t\t{% endverbatim %}\r\n\t\t\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodSubject.js\"></script>\r\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\">\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n{% verbatim %}\r\n\t<body ng-controller=\"SubjectCtrl\">\r\n\t\t\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n\t\t\t<div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n\t\t\t\t<div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n\t\t\t\t<ul class=\"nav navbar-nav\">\r\n\t\t\t\t\t<li class=\"active\">\r\n\t\t\t\t\t\t<a>User ID: <span>{{ $root.user_id }}</span></a>\r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t\r\n\t\t<div class=\"container\">\r\n\t\t\t<div class=\"row\">\r\n\t\t\t\t<div class=\"col-lg-12\">\r\n\t\t\t\t\tPlease wait for experiment to start...\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t</body>\r\n{% endverbatim %}\r\n</html>\r\n\r\n", "name": "Wait", "css": "body {\r\n  padding-top: 60px;\r\n}\r\n\r\n", "js": "Redwood.controller(\"SubjectCtrl\", [\"$rootScope\", \"$scope\", \"RedwoodSubject\", function($rootScope, $scope, rs) {\r\n\trs.on_load(function() {\r\n\t\trs.next_period();\r\n\t});\r\n}]);\r\n\r\n"}, "model": "expecon.page", "pk": 16}, {"fields": {"experiment": 4, "html": "{% load verbatim %}\r\n<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n<head>\r\n {% verbatim %}\r\n <title>S{{ $root.user_id }} || In Progress</title>\r\n {% endverbatim %}\r\n\r\n <script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n <script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n <script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n <script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n <script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n <!--<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodSubject.js\"></script>-->\r\n <script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/synchronizedStopWatch.js\"></script>\t\t\r\n\r\n <script language=\"javascript\" type=\"text/javascript\" src=\"{{ STATIC_URL}}framework/js/lib/flot/jquery.flot.js\"></script>\r\n <script language=\"javascript\" type=\"text/javascript\" src=\"{{ STATIC_URL}}framework/js/lib/flot/jquery.flot.selection.js\"></script>\r\n <script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/d3/d3.js\"></script>\r\n\r\n <link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\">\r\n <script type=\"text/javascript\">\r\n   {{ js }}\r\n </script>\r\n <style type=\"text/css\">\r\n   {{ css }}\r\n </style>\r\n</head>\r\n{% verbatim %}\r\n<body style=\"padding-top:60px\" ng-controller=\"SubjectCtrl\">\r\n  <div class='container'>\r\n\r\n    <div class=\"navbar navbar-fixed-top container\">\r\n      <div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n        <div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n        <ul class=\"nav navbar-nav\">\r\n          <li class=\"active\">\r\n            <a id=\"subj\">User ID: <span>{{$root.user_id}}</span></a>\r\n          </li>\r\n        </ul>\r\n        <div class=\"navbar-right\">\r\n          <div id=\"period\" class=\"navbar-text\">Period: <span>{{$root.period}}</span></div>\r\n          <div id=\"paid\" class=\"navbar-text\">Paid: </div>\r\n          <div id=\"curr_score\" class=\"navbar-text\">Score:</div>\r\n          <div id=\"time\" class=\"navbar-text\">Time:</div>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n    \r\n    <!-- Modal -->\r\n    <div class=\"modal fade\" id=\"myModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\">\r\n\r\n      <div class=\"modal-dialog\">\r\n        <div class=\"modal-content\">\r\n        </div>\r\n      </div>\r\n    </div>\r\n\r\n\r\n\r\n\r\n    <div class='row'>\r\n      <div class='col-md-9'>\r\n        <div class=\"progress\" id=\"progress\">\r\n          <div id='progBar' class=\"progress-bar progress-bar-striped active\"  role=\"progressbar\" aria-valuenow=\"0\" aria-valuemin=\"0\" aria-valuemax=\"130\" style=\"width: 0%\">\r\n\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div class='col-md-3'>\r\n        <h4 id = \"total_score\" style=\"visibility:hidden\">Total Score: </h4>\r\n      </div>\r\n    </div>\r\n\r\n    <div class='row'>\r\n      <h3 id=\"color\">Your color</h3>\r\n      <p id=\"x_ref\"></p>\r\n      <p id=\"y_ref\"></p> \r\n      <p id=\"x_loc\"></p>\r\n      <p id=\"test\"></p>\r\n      <h2 id=\"select\" style=\"color:red\"></h2>\r\n    </div>\r\n    <div class='row'>\r\n      <div id=\"placeholder\" style=\"height:400px; width:400px; position: absolute;\" class=\"demo-placeholder actionspace\">  </div>\r\n      <div class=\"col-md-8 col-md-offset-5\">\r\n        <div id=\"placeholder2\" style=\"height:300px; width:420px\" class=\"demo-placeholder\">  </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</body>\r\n{% endverbatim %}\r\n</html>\r\n\r\n", "name": "Start", "css": "#placeholder2 {\r\n  margin-left: -15px;\r\n}\r\n\r\n#actionCircle {\r\n  fill: white;\r\n  stroke: black;\r\n}\r\n\r\n#1 {\r\n  transition: all .5s;\r\n}\r\n\r\n#2 {\r\n  transition: all .5s;\r\n}\r\n\r\n.playerCircle {\r\n  transition:-webkit-transform 0.5s, fill 0.5s;\r\n}\r\n\r\n.playerCircle:hover {\r\n  fill: steelblue;\r\n  /*-webkit-transform: scale(1.2, 1.2);*/\r\n}\r\n#hoverLine {\r\n  pointer-events: none;\r\n}\r\n\r\n.actionspace {\r\n  padding-right: 5px;\r\n}\r\n\r\n#actionspace1 .overlay {\r\n  background: -webkit-linear-gradient(right,rgba(255,255,255,0),rgba(255,255,255,1)); /*Safari 5.1-6*/\r\n  background: -o-linear-gradient(left,rgba(255,255,255,0),rgba(255,255,255,1)); /*Opera 11.1-12*/\r\n  background: -moz-linear-gradient(left,rgba(255,255,255,0),rgba(255,255,255,1)); /*Fx 3.6-15*/\r\n  background: linear-gradient(to left, rgba(255,255,255,0), rgba(255,255,255,1)); /*Standard*/\r\n}\r\n#actionspace3 .overlay {\r\n  background: -webkit-linear-gradient(left,rgba(255,255,255,0),rgba(255,255,255,1)); /*Safari 5.1-6*/\r\n  background: -o-linear-gradient(right,rgba(255,255,255,0),rgba(255,255,255,1)); /*Opera 11.1-12*/\r\n  background: -moz-linear-gradient(right,rgba(255,255,255,0),rgba(255,255,255,1)); /*Fx 3.6-15*/\r\n  background: linear-gradient(to right, rgba(255,255,255,0), rgba(255,255,255,1)); /*Standard*/\r\n}\r\n", "js": "/**\r\n * !!!!CAUTION!!!! Be careful not to use this file with past experiments\r\n * This file has been further modified by Simon Seo (simon.seo@nyu.edu, 09 Dec 2016) to implement siloing\r\n * from commit a3b79f866ed7d897685fbeb72eee6d2f68ade125 (20 Apr 2015)\r\n * of Leeps-Lab/RedwoodFramework (https://github.com/Leeps-Lab/RedwoodFramework)\r\n */\r\n\r\n\r\nRedwood.factory(\"RedwoodSubject\", [\"$q\", \"$rootScope\", \"$timeout\", \"RedwoodCore\", function($q, $rootScope, $timeout, rw) {\r\n\r\n\tvar loadingModal = {\r\n\t\theader: \"Loading\",\r\n\t\tcontent: \"Please wait\",\r\n\t\tfooter: \"\",\r\n\t\tinvisible: true\r\n\t};\r\n\tvar pausedModal = {\r\n\t\theader: \"Paused\",\r\n\t\tcontent: \"Please wait\",\r\n\t\tfooter: \"\"\r\n\t};\r\n\r\n\t$rootScope.$emit('messageModal', 'loadingModal', loadingModal);\r\n\r\n\tvar rs = {};\r\n\r\n\trs.user_id = rw.user_id;\r\n\trs.subjects = [];\r\n\t$rootScope.subjects = rs.subjects;\r\n\trs.subject = {};\r\n\t$rootScope.subject = rs.subject;\r\n\trs.points = 0;\r\n\trs.accumulated_points = 0;\r\n\t$rootScope.points = 0;\r\n\t$rootScope.totalPoints = 0;\r\n\trs.is_realtime = false;\r\n\trs._messaging_enabled = false;\r\n\r\n\trs._send_queue = [];\r\n\trs._event_handlers = {};\r\n\trs._msg_handlers = {};\r\n\r\n\trs._pause = {};\r\n\r\n\trs.data = {};\r\n\trs.new_period_requested = false;\r\n\r\n\trs._handle_event_msg = function(msg) {\r\n\t\tif(msg.Period != rw.periods[msg.Sender]) return;\r\n\t\trs._broadcast_event(msg.Key, msg.Value);\r\n\t};\r\n\r\n\trs._handle_msg = function(msg) {\r\n\t\tif(msg.Sender != \"admin\" && msg.Period != rw.periods[msg.Sender]) return;\r\n\t\tif(rs._msg_handlers[msg.Key]) {\r\n\t\t\tfor(var i = 0, l = rs._msg_handlers[msg.Key].length; i < l; i++) {\r\n\t\t\t\trs._msg_handlers[msg.Key][i](msg.Sender, msg.Value);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\trs._broadcast_event = function(eventName, value) {\r\n\t\tif(rs._event_handlers[eventName]) {\r\n\t\t\tfor(var i = 0, l = rs._event_handlers[eventName].length; i < l; i++) {\r\n\t\t\t\trs._event_handlers[eventName][i](value);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\trs._enable_messaging = function() {\r\n\t\trs._messaging_enabled = true;\r\n\t\tvar message = rs._send_queue.shift();\r\n\t\twhile(message) {\r\n\t\t\trw.send(message.key, message.value, message.opts);\r\n\t\t\tmessage = rs._send_queue.shift();\r\n\t\t}\r\n\t};\r\n\r\n\trs._send = function(key, value, opts) {\r\n\t\topts = opts || {};\r\n\t\tif(angular.isNullOrUndefined(opts.period)) opts.period = rs.period;\r\n\t\tif(angular.isNullOrUndefined(opts.group)) opts.group = rs._group;\r\n\t\tif(angular.isNullOrUndefined(opts.sender)) opts.sender = rs.user_id;\r\n\r\n\t\tif(rs._messaging_enabled) {\r\n\t\t\trw.send(key, value, opts);\r\n\t\t} else {\r\n\t\t\trs._send_queue.push({key: key, value: value, opts: opts});\r\n\t\t}\r\n\t};\r\n\r\n\trs.trigger = function(eventName, value) {\r\n\t\trs._send(eventName, value);\r\n\t};\r\n\r\n\trs.on = function(eventName, f) {\r\n\t\tif(!rs._event_handlers[eventName]) {\r\n\t\t\trs._event_handlers[eventName] = [];\r\n\t\t\trw.recv_self(eventName, rs._handle_event_msg);\r\n\t\t}\r\n\t\trs._event_handlers[eventName].push(f);\r\n\t};\r\n\r\n\trs.send = function(key, value) {\r\n\t\trs._send(key, value);\r\n\t};\r\n\r\n\trs.recv = function(key, f) {\r\n\t\tif(!rs._msg_handlers[key]) {\r\n\t\t\trs._msg_handlers[key] = [];\r\n\t\t\trw.recv_others(key, rs._handle_msg);\r\n\t\t}\r\n\t\trs._msg_handlers[key].push(f);\r\n\t};\r\n\r\n\trs.recv(rw.KEY.__set_config__, function(sender, value) {\r\n\t\trs.configs = rw.configs;\r\n\t});\r\n\r\n\trw.recv_self(\"__set_period__\", function(msg) {\r\n\t\trs.period = msg.Value.period;\r\n\t\trs.config = {};\r\n\t\tfor(var i = 0, l = rw.configs.length; i < l; i++) {\r\n\t\t\tvar config = rw.configs[i];\r\n\t\t\tif ((!config.period && rs.period == i + 1) || config.period === rs.period) {\r\n\t\t\t\tif (!config.group || config.group == rs._group) {\r\n\t\t\t\t\trs.config = config;\r\n\t\t\t\t\t$rootScope.config = config;\r\n\t\t\t\t\tif(rs.config.pause) {\r\n\t\t\t\t\t\trs._pause[rs.period] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(rs.period === 0) {\r\n\t\t\trw.set_page(\"Wait\", rs.user_id);\r\n\t\t} else if(Object.size(rs.config) === 0) {\r\n\t\t\trw.set_page(\"Finish\", rs.user_id);\r\n\t\t} else {\r\n\t\t\trw.set_page(\"Start\", rs.user_id);\r\n\t\t}\r\n\t});\r\n\r\n\trs.set_points = function(points) {\r\n\t\trs.trigger(\"__set_points__\", { period: rs.period, points: parseFloat(points) });\r\n\t};\r\n\r\n\trs.add_points = function(points) {\r\n\t\trs.trigger(\"__set_points__\", { period: rs.period, points: parseFloat(rs.points + points) });\r\n\t};\r\n\r\n\trs.on(\"__set_points__\", function(value) {\r\n\t\trs.self.accumulated_points += (value.points - rs.points);\r\n\t\trs.accumulated_points = rs.self.accumulated_points;\r\n\t\trs.self.points = value.points;\r\n\t\trs.points = value.points;\r\n\r\n\t\t$rootScope.totalPoints = rs.accumulated_points;\r\n\t\t$rootScope.periodPoints = rs.points;\r\n\t});\r\n\r\n\trs.recv(\"__set_points__\", function(sender, value) {\r\n\t\trs.subject[sender].accumulated_points += (value.points - rs.subject[sender].points);\r\n\t\trs.subject[sender].points = value.points;\r\n\t});\r\n\r\n\trs.on_points_changed = function(f) {\r\n\t\trs.on(\"__set_points__\", function(value) {\r\n\t\t\tf(value.points);\r\n\t\t});\r\n\t};\r\n\trs.recv_points_changed = function(f) {\r\n\t\trs.recv(\"__set_points__\", function(sender, value) {\r\n\t\t\tf(sender, value.points);\r\n\t\t});\r\n\t};\r\n\r\n\trs.set = function(key, value) {\r\n\t\trs._send(key, value, {period: 0});\r\n\t};\r\n\r\n\trs.save = function(key, value) {\r\n\t\trs._send(key, value);\r\n\t};\r\n\trs.retrieve = function(key, f) {\r\n\t\trs.retrieveMany([key], function(results) {\r\n\t\t\tf(results[key]);\r\n\t\t});\r\n\t};\r\n\trs.retrieveMany = function(key_array, f) {\r\n\t\trs._retrieve(key_array, [rs.user_id], function(results) {\r\n\t\t\tvar repackaged = {};\r\n\t\t\tfor(var i = 0, l = key_array.length; i < l; i++) {\r\n\t\t\t\trepackaged[key_array[i]] = results[key_array[i]][rs.user_id];\r\n\t\t\t}\r\n\t\t\tf(repackaged);\r\n\t\t});\r\n\t};\r\n\trs._retrieve = function(key_array, user_id_array, f) {\r\n\t\trs._retrieve_callbacks = rs._retrieve_callbacks || [];\r\n\t\trs._retrieve_callbacks.push(f);\r\n\t\tif(!rw.__sync__.in_progress) {\r\n\t\t\tvar results = {};\r\n\t\t\tfor(var i = 0, l = key_array.length; i < l; i++) {\r\n\t\t\t\tresults[key_array[i]] = {};\r\n\t\t\t\tfor(var j = 0, l2 = user_id_array.length; j < l2; j++) {\r\n\t\t\t\t\tresults[key_array[i]][user_id_array[j]] = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(rs.period > 1) {\r\n\t\t\t\trw.get_period(rs.period - 1, function (m) {\r\n\t\t\t\t\tvar q = m.Value;\r\n\t\t\t\t\tfor(var i = 0, l = q.length; i < l; i++) {\r\n\t\t\t\t\t\tvar msg = q[i];\r\n\t\t\t\t\t\tif(user_id_array.indexOf(msg.Sender) > -1 && key_array.indexOf(msg.Key) > -1) {\r\n\t\t\t\t\t\t\tresults[msg.Key][msg.Sender] = msg.Value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\trs.save(\"_rs_retrieve\", results);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\trs.save(\"_rs_retrieve\", results);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\trw.recv_self(\"_rs_retrieve\", function(msg) {\r\n\t\tif(msg.Period != rw.periods[msg.Sender]) return;\r\n\t\tvar f = rs._retrieve_callbacks.shift();\r\n\t\tf(msg.Value);\r\n\t});\r\n\r\n\trs.next_period = function(delay_secs) {\r\n\t\tdelay_secs = delay_secs || 0;\r\n\t\t/**\r\n\t\t * _enable_messaging is a function not a boolean. \r\n\t\t * Replacing it with seemingly proper variable _messaging_enabled removed one bug.\r\n\t\t * The replacement introduced another bug: cummulative payoff was not logged properly.\r\n\t\t * I commented out both.\r\n\t\t * The new bug as well as the old bug are nowhere to be found.\r\n\t\t * The intention of the original line is unclear.\r\n\t\t */\r\n\t\t// rs._enable_messaging = false;\r\n\t\t// rs._messaging_enabled = false;\r\n\t\trs.timeout(function(){\r\n\t\t\trw.send('_next_period');\r\n\t\t}, delay_secs * 1000);\r\n\t};\r\n\r\n\trs.on(\"_next_period\", function() {\r\n\t\t// rs._enable_messaging = false;\r\n\t\t// rs._messaging_enabled = false;\r\n\t\tif (rs.self.get(\"_accumulated_points\")) { //if exists\r\n\t\t\tvar arr = JSON.parse(JSON.stringify(rs.self.get(\"_accumulated_points\")));\r\n\t\t\tarr.push(rs.accumulated_points);\r\n\t\t\trs.set(\"_accumulated_points\", JSON.stringify(arr));\r\n\t\t}\r\n\t\telse {\r\n\t\t\trs.set(\"_accumulated_points\", JSON.stringify([rs.accumulated_points]));\r\n\t\t}\r\n\t\t// rs.set(\"_accumulated_points\", rs.accumulated_points);\r\n\t\trw.set_period(rs.period + 1);\r\n\t});\r\n\r\n\trs.exclude = function() {\r\n\t\tvar lastGroup = rs._group;\r\n\t\tangular.forEach(rw.groups, function(group) {\r\n\t\t\tlastGroup = Math.max(group, lastGroup);\r\n\t\t});\r\n\t\trs._group = lastGroup + 1;\r\n\t\trw.set_group(rs._group, rs.user_id);\r\n\t\trs.set('excluded', true);\r\n\t};\r\n\trs.finish = function(delay_secs) {\r\n\t\tdelay_secs = delay_secs || 0;\r\n\t\trs.timeout(function(){rs.trigger(\"_finish\");}, delay_secs * 1000);\r\n\t};\r\n\r\n\trs.on(\"_finish\", function() {\r\n\t\trs.set(\"_accumulated_points\", rs.accumulated_points);\r\n\t\trw.set_period(rw.configs.length + 1);\r\n\t});\r\n\r\n\trw.on_sync_complete(function() {\r\n\t\trs.is_realtime = true;\r\n\t});\r\n\r\n\trs._delayIfNotRealtime = function(f) {\r\n\t\tif(rw.__sync__.in_progress) {\r\n\t\t\trw.on_sync_complete(f);\r\n\t\t} else {\r\n\t\t\tf();\r\n\t\t}\r\n\t};\r\n\r\n\trs._timeout_callbacks = {};\r\n\tvar timeoutKey = 1;\r\n\trs.timeout = function(f, delay_ms) {\r\n\t\tdelay_ms = delay_ms || 0;\r\n\t\tvar key = timeoutKey++;\r\n\t\trs._timeout_callbacks[key] = {f: f, delay: delay_ms};\r\n\t\trs._delayIfNotRealtime(function() {\r\n\t\t\tif(rs._timeout_callbacks[key]) {\r\n\t\t\t\trs._timeout_callbacks[key].timeout = $timeout(function() {\r\n\t\t\t\t\trs._timeout_callbacks[key].f();\r\n\t\t\t\t\tdelete rs._timeout_callbacks[key];\r\n\t\t\t\t}, rs._timeout_callbacks[key].delay);\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn key;\r\n\t};\r\n\trs.timeout.cancel = function(key) {\r\n\t\tif(!key || !rs._timeout_callbacks[key]) return;\r\n\t\tif(rs._timeout_callbacks[key] && rs._timeout_callbacks[key].timeout) {\r\n\t\t\t$timeout.cancel(rs._timeout_callbacks[key].timeout);\r\n\t\t}\r\n\t\tdelete rs._timeout_callbacks[key];\r\n\t};\r\n\r\n\trw.recv_subjects(\"__set_group__\", function(msg) {\r\n\t\tif(msg.Sender == rs.user_id) {\r\n\t\t\trs._group = msg.Value.group;\r\n\t\t}\r\n\t\tif(!rs.new_period_requested) {\r\n\t\t\trs.subjects.push({\r\n\t\t\t\tuser_id: msg.Sender,\r\n\t\t\t\tpoints: 0,\r\n\t\t\t\taccumulated_points: 0,\r\n\t\t\t\tpoints_by_period: function() {\r\n\t\t\t\t\tvar results = [];\r\n\t\t\t\t\tif(!this.data[\"_accumulated_points\"] || !this.data[\"_accumulated_points\"].length) {\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults.push(this.data[\"_accumulated_points\"][0]);\r\n\t\t\t\t\tfor(var i = 1; i < this.data[\"_accumulated_points\"].length; i++) {\r\n\t\t\t\t\t\tresults.push(this.data[\"_accumulated_points\"][i] - this.data[\"_accumulated_points\"][i - 1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t},\r\n\t\t\t\tpoints_by_period_silo: function() {\r\n\t\t\t\t\t//rs.subject[rs.user_id].data[\"_accumulated_points\"] = [[0.012041, 0.46323, ...]]\r\n\t\t\t\t\t//this.data[\"_accumulated_points\"] = [[0.012041, 0.46323, ...]]\r\n\t\t\t\t\tvar results = [];\r\n\t\t\t\t\tif(!this.data[\"_accumulated_points\"] || !this.data[\"_accumulated_points\"].length) {\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar arr = this.data[\"_accumulated_points\"];\r\n\t\t\t\t\tvar last = arr.length - 1;\r\n\t\t\t\t\tresults.push(arr[last][0]);\r\n\t\t\t\t\tconsole.log(\"data array\", JSON.stringify(arr));\r\n\t\t\t\t\tconsole.log(\"data last array\", JSON.stringify(arr[last]));\r\n\t\t\t\t\tfor(var i = 1; i < arr[last].length; i++) {\r\n\t\t\t\t\t\tresults.push(arr[last][i] - arr[last][i - 1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t},\r\n\t\t\t\tdata: {\r\n\t\t\t\t\t_synced: []\r\n\t\t\t\t},\r\n\t\t\t\tgetAccumulatedPoints: function(key) {\r\n\t\t\t\t\tkey = key ? key : \"_accumulated_points\";\r\n\t\t\t\t\tif (angular.isNullOrUndefined(this.data[key])) {\r\n\t\t\t\t\t\treturn undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar arr = this.data[key];\r\n\t\t\t\t\t\tvar lastGroup = arr.length - 1;\r\n\t\t\t\t\t\tvar last = arr[lastGroup].length - 1;\r\n\t\t\t\t\t\treturn arr[lastGroup][last];\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tget: function(key) {\r\n\t\t\t\t\treturn (angular.isNullOrUndefined(this.data[key]) ? undefined : this.data[key].last());\r\n\t\t\t\t},\r\n\t\t\t\tgetPrevious: function(key) {\r\n\t\t\t\t\tif (key == \"_accumulated_points\") { //data._accumulated_points will be an array\r\n\t\t\t\t\t\tif (angular.isNullOrUndefined(this.data[key])) {\r\n\t\t\t\t\t\t\treturn undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (this.data[key][0].length > 1) {\r\n\t\t\t\t\t\t\tvar arr = this.data[key];\r\n\t\t\t\t\t\t\tvar last = arr.length - 1;\r\n\t\t\t\t\t\t\treturn arr[last][arr[last].length - 2];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\treturn undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn (angular.isNullOrUndefined(this.data[key]) ? undefined\r\n\t\t\t\t\t\t\t: (this.data[key].length > 1 ? this.data[key][this.data[key].length - 2] : undefined));\r\n\t\t\t\t},\r\n\t\t\t\t_loaded: false\r\n\t\t\t});\r\n\t\t\trs.subjects.sort(function(a,b) {\r\n\t\t\t\treturn parseInt(a.user_id) - parseInt(b.user_id);\r\n\t\t\t});\r\n\t\t\trs.subjects.forEach(function(subject) {\r\n\t\t\t\trs.subject[subject.user_id] = subject;\r\n\t\t\t});\r\n\t\t\trs.self = rs.subject[rs.user_id];\r\n\t\t\trs.otherSubjects = rs.subjects.filter(function(subject) {\r\n\t\t\t\treturn subject.user_id !== rs.user_id;\r\n\t\t\t});\r\n\t\t\t$rootScope.otherSubjects = rs.otherSubjects;\r\n\t\t}\r\n\t});\r\n\r\n\trw.recv_subjects(\"*\", function(msg) {\r\n\t\tif((msg.Period > 0 && msg.Period != rw.periods[msg.Sender])\r\n\t\t\t\t|| !rs.subject[msg.Sender]) return;\r\n\t\tif(msg.Key == \"_accumulated_points\") { //needed for siloing\r\n\t\t\tmsg.Value = JSON.parse(msg.Value);\r\n\t\t}\r\n\t\tif(!rs.data[msg.Key]) {\r\n\t\t\trs.data[msg.Key] = [];\r\n\t\t}\r\n\t\trs.data[msg.Key].push(msg.Value);\r\n\t\tif(!rs.subject[msg.Sender].data[msg.Key]) {\r\n\t\t\trs.subject[msg.Sender].data[msg.Key] = [];\r\n\t\t}\r\n\t\trs.subject[msg.Sender].data[msg.Key].push(msg.Value);\r\n\t});\r\n\r\n\trw.recv_subjects(\"__page_loaded__\", function(msg) {\r\n\t\tif(msg.Period != rw.periods[msg.Sender]\r\n\t\t\t|| rw.groups[msg.Sender] != rs._group\r\n\t\t\t|| !rs.subject[msg.Sender]) return;\r\n\t\trs.subject[msg.Sender]._loaded = true;\r\n\t\tvar not_loaded = rs.subjects.some(function(subject) {return !subject._loaded;});\r\n\t\tif(!not_loaded) {\r\n\t\t\trs._enable_messaging();\r\n\t\t}\r\n\t});\r\n\r\n\tvar barriers = {};\r\n\trs.synchronizationBarrier = function(barrierId, subjectIds) {\r\n\t\tvar deferred = $q.defer();\r\n\t\tbarrierId += '_' + rs.period;\r\n\t\tbarriers[barrierId] = barriers[barrierId] || {received: []};\r\n\t\tif(subjectIds) {\r\n\t\t\tbarriers[barrierId].subjectIds = angular.copy(subjectIds);\r\n\t\t\tbarriers[barrierId].subjectIds.push(rs.self.user_id);\r\n\t\t}\r\n\t\tbarriers[barrierId].deferred = deferred;\r\n\t\trs.trigger(\"_at_barrier\", barrierId);\r\n\t\treturn deferred.promise;\r\n\t};\r\n\trw.recv_subjects('_at_barrier', function(msg) {\r\n\t\tbarriers[msg.Value] = barriers[msg.Value] || {received: []};\r\n\t\tbarriers[msg.Value].received.push(msg.Sender);\r\n\t\tcheckBarrier(msg.Value);\r\n\t});\r\n\tfunction checkBarrier(barrierId) {\r\n\t\tvar barrier = barriers[barrierId];\r\n\t\tif(!barrier.deferred) return;\r\n\t\tif(barrier.subjectIds) {\r\n\t\t\tif(barrier.subjectIds.some(function(id) {\r\n\t\t\t\treturn barrier.received.indexOf(id) < 0;\r\n\t\t\t})) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif(rs.subjects.some(function(subject) {\r\n\t\t\t\treturn barrier.received.indexOf(subject.user_id) < 0;\r\n\t\t\t})) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbarrier.deferred.resolve();\r\n\t\tdelete barriers[barrierId];\r\n\t}\r\n\r\n\trs._start_period = function() {\r\n\t\trs.timeout(function() {\r\n\t\t\t$rootScope.$emit('messageModal', 'loadingModal', false);\r\n\t\t});\r\n\r\n\t\twhile(rs._on_load_callbacks.length) {\r\n\t\t\t(rs._on_load_callbacks.shift())();\r\n\t\t}\r\n\t};\r\n\r\n\trw.on_load(function() {\r\n\t\t$rootScope.period = rs.period;\r\n\t\trs.synchronizationBarrier('_on_load').then(function() {\r\n\r\n\t\t\tif(rs.config && $.isArray(rs.config.groups) && rs.config.groups.length > 0 && $.isArray(rs.config.groups[0])) {\r\n\t\t\t\tfor(var i = 0; i < rs.config.groups.length; i++) {\r\n\t\t\t\t\tfor(var j = 0; j < rs.config.groups[i].length; j++) {\r\n\t\t\t\t\t\tif(rs.subject[rs.config.groups[i][j]]) {\r\n\t\t\t\t\t\t\trs.subject[rs.config.groups[i][j]].groupForPeriod = i + 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor(var i = 0, l = rs.subjects.length; i < l; i++) {\r\n\t\t\t\trs.subjects[i].accumulated_points += (rs.subjects[i].getAccumulatedPoints() ? rs.subjects[i].getAccumulatedPoints() : 0);\r\n\t\t\t}\r\n\t\t\trs.accumulated_points = rs.self.accumulated_points;\r\n\t\t\t$rootScope.totalPoints = rs.accumulated_points;\r\n\r\n\t\t\tif(rs._pause[rs.period]) {\r\n\t\t\t\trw.send(\"__paused__\", { period: rs.period }, { period: rs.period, group: rs._group, sender: rs.user_id });\r\n\t\t\t} else {\r\n\t\t\t\trs._start_period();\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n\r\n\trw.recv_self(\"__paused__\", function(msg) {\r\n\t\t$rootScope.$emit('messageModal', 'pausedModal', pausedModal);\r\n\t});\r\n\r\n\trw.recv_self(\"__resume__\", function(msg) {\r\n\t\tif(rs._pause[msg.Value.period]) {\r\n\t\t\trs._pause[msg.Value.period] = false;\r\n\t\t\tif(rs.period === msg.Value.period) {\r\n\t\t\t\t$rootScope.$emit('messageModal', 'pausedModal', false);\r\n\t\t\t\trs._start_period();\r\n\t\t\t\trs.send(\"__resumed__\", {period: rs.period});\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\trs._on_load_callbacks = [];\r\n\trs.on_load = function(f) {\r\n\t\trs._on_load_callbacks.push(f);\r\n\t};\r\n\r\n\t$timeout(function() {\r\n\t\trw.__connect__();\r\n\t});\r\n\r\n\treturn rs;\r\n}]);\r\n\r\nRedwood.controller(\"SubjectCtrl\", [\"$rootScope\", \"$scope\", \"RedwoodSubject\", 'SynchronizedStopWatch', \"RedwoodCore\", function($rootScope, $scope, rs, SynchronizedStopWatch, r) {\r\n    var id = 0;              //player id\r\n    var current_period = 0;\r\n    var curr_subperiods = 1;\r\n    var num_of_players = 0;  //number of players in our group\r\n    var price = 0;\r\n    var network = {};        //player object\r\n    var options;             //plot 1 options\r\n    var p2_options;          //plot 2 options\r\n    var player_pos = [];     //location of opponent's positions\r\n    var target_pos = [0, 0]; //our current target location for continuous time\r\n    var plot;\r\n    var x_rate = 1;          //percent change per second along x axis\r\n    var y_rate = 1;          //percent change per second along y axis\r\n    var keeper;              //game synchronizer from our group\r\n    var chosen = false;      //flag\r\n    var new_loc = 0;\r\n    var new_pos = 0;\r\n    var transport_cost;\r\n    var time = 0;\r\n    var tend;\r\n    var subperiods = 0;\r\n    var paid_round = false;\r\n    var period_length = 0;\r\n    var t;                   //config field\r\n    // var r;                   //redwood\r\n    var intersects = [];     //array of intersect locations on x axis\r\n    var colors = ['#FF6699', '#339966', '#0066CC', '#CCA300'];\r\n    var mouse = [];          //for drawing crosshairs on plot\r\n    var cummulative_payoff = 0;\r\n    var flow_payoff = [];    //should be a better way of storing flow payoffs for scalability reasons..\r\n    var flow_payoff2 = [];\r\n    var game_type = \"continuous\";\r\n    var debug1 = false;       //player 'Vs'\r\n    var debug2 = false;      //intersect lines\r\n    var debug3 = false;      //market share box shading\r\n    var col;                 //player's blue color. may be unnecessary to store this info now\r\n    var p2_t = 0;            //fake time interval for plotting flow payoffs. should be changed\r\n    var flow_opts;           //flow payoff debug options\r\n    var last_20 = [];\r\n                             //var l = 0;\r\n    var my_pos;              //player's current location and price \r\n    var sub_pay = [\r\n        [],\r\n        []\r\n    ];                       //stores each player's payoffs at end of round for discrete games\r\n    var scalar_x = Number(1);\r\n    var scalar_y = Number(1);\r\n    var allow_x = 1;         //discrete choosing settings\r\n    var allow_y = 0;\r\n    var price_subrounds = 1; //how many price rounds after a location round we have\r\n    var curr_sub_y = 0;\r\n    var curr_i = 0;\r\n    var p2_ticks = [];\r\n    var flag = 0;            //for restarting position after new subgames\r\n    var waiting = 1;         //to disable user interface\r\n    var in_group = [];       //who is in my redwood group\r\n    var group_num = 0;\r\n    var silo_num = 0;\r\n    var r_debug = 0;         //Chooses points automatically. Faulty (Nov.6, 2016)\r\n\r\n    var total_flow = [];\r\n    var total_flow2 = [];\r\n\r\n    var filler = [0, 0];     //for making bar graphs\r\n\r\n    var quadratic = false;\r\n    var linear = true;\r\n\r\n    var payoff_mirror = 0;\r\n    /*\r\n     * returns color associated with a player\r\n     */\r\n    function player_color(key) {\r\n        for (var i = 0; i < network.players.length; ++i)\r\n            if (network.players[i].id == key) return network.players[i].color;\r\n\r\n        return '#000000';\r\n    }\r\n\r\n    /*\r\n     * returns all player's positions as x,y points\r\n     */\r\n    function get_opp_pos() {\r\n        var res = [];\r\n        for (var i = 0; i < player_pos.length; ++i) {\r\n            res.push([\r\n                [player_pos[i][0], player_pos[i][1]]\r\n            ]);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * returns points to draw a line on given axis to indicate where players can choose\r\n     */\r\n    function gen_targ_line(axis) {\r\n        var res = [];\r\n        if (axis == \"x\") {\r\n            res.push([Number(new_loc) + 0.015, 0]);\r\n            res.push([Number(new_loc) - 0.015, 0]);\r\n            res.push([Number(new_loc), 0.015]);\r\n            res.push([Number(new_loc) + 0.015, 0]);\r\n            res.push([Number(new_loc), 0.015]);\r\n            res.push([Number(new_loc), 1]);\r\n        } else if (axis == \"y\") {\r\n            res.push([0, Number(new_pos) + 0.015]);\r\n            res.push([0, Number(new_pos) - 0.015]);\r\n            res.push([0.015, Number(new_pos)]);\r\n            res.push([0, Number(new_pos) + 0.015]);\r\n            res.push([0.015, Number(new_pos)]);\r\n            res.push([1, Number(new_pos)]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * returns market boundary points for a given player to draw 'payoff area' box\r\n     */\r\n    function get_market_bounds(key) {\r\n        var res = [];\r\n        for (var i in network.players) {\r\n            if (network.players[i].id == key) {\r\n                res.push(network.players[i].bound_lo);\r\n                res.push(network.players[i].bound_hi);\r\n                res.push(network.players[i].price);\r\n            }\r\n        }\r\n\r\n        var out = [];\r\n        out.push([res[0], null]);\r\n\r\n        out.push([res[0], 0]);\r\n        out.push([res[0], res[2]]);\r\n\r\n\r\n        out.push([res[1], res[2]]);\r\n        out.push([res[1], 0]);\r\n        out.push([res[1], null]);\r\n\r\n        return out;\r\n    }\r\n\r\n    var tmp_a0 = [];\r\n    var tmp_a1 = [];\r\n\r\n    /**\r\n     * Used to hold the reflections. This is needed because Flot will try to connect\r\n     * points even if there's a break in the function, so we split up the positive\r\n     * reflections and the negative ones for both players.\r\n     */\r\n    var tmp_a0_front = [];\r\n    var tmp_a0_back = [];\r\n    var tmp_a1_front = [];\r\n    var tmp_a1_back = [];\r\n\r\n    var market_b = [];\r\n\r\n    /*\r\n     * redraws and updates data for plot 1\r\n     */\r\n    function update_plot() {\r\n        if (waiting) return;\r\n\r\n        sort_players();\r\n        var tmp = [target_pos];\r\n        var i = get_index_by_id(id);\r\n\r\n        get_players();\r\n\r\n        var tmp_col = '#C7C7C7';\r\n\r\n        if (game_type == \"continuous\") {\r\n            targ_line = [];\r\n            my_pos = [\r\n                [player_pos[i][0], player_pos[i][1]]\r\n            ];\r\n        } else if (game_type != \"continuous\") {\r\n            var axis = \"\";\r\n            if (allow_x && !allow_y) axis = \"x\";\r\n            else if (!allow_x && allow_y) axis = \"y\";\r\n\r\n            tmp_col = '#B20000';\r\n            targ_line = gen_targ_line(axis); //draw axis choosing line if in discrete time\r\n        }\r\n\r\n        tmp_a0 = [];\r\n        tmp_a1 = [];\r\n\r\n        //Used to hold the reflections. This is needed because Flot will try to connect\r\n        //points even if there's a break in the function, so we split up the positive\r\n        //reflections and the negative ones for both players.\r\n        tmp_a0_front = [];\r\n        tmp_a0_back = [];\r\n        tmp_a1_front = [];\r\n        tmp_a1_back = [];\r\n\r\n        market_b = [];\r\n        intersects = [0, mouse[0], 1];\r\n\r\n        var opp_pos = get_opp_pos();\r\n\r\n        //This isn't done for n players -- only players 0 & 1\r\n\r\n        if (debug1) { // display payoff debug options, player \"V's\"\r\n            //if we're doing linear, use linear v generator, otherwise do quad\r\n            if (linear) {\r\n                if (payoff_mirror) {\r\n                    tmp_a0 = a_mirror(0);\r\n                    tmp_a1 = a_mirror(1);\r\n                } else {\r\n                    tmp_a0 = a(0);\r\n                    tmp_a1 = a(1);\r\n                }\r\n            } else {\r\n                if (payoff_mirror) {\r\n                    tmp_a0 = quad_mirror(0);\r\n                    tmp_a1 = quad_mirror(1);\r\n                } else {\r\n                    tmp_a0 = quad(0);\r\n                    tmp_a1 = quad(1);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (debug2) { //market intersection lines\r\n            intersects = find_intersect_pts();\r\n            intersects[num_of_players + 1] = mouse[0];\r\n            options.xaxis.ticks = intersects;\r\n        }\r\n\r\n        if (debug3) { //payoff area shading\r\n            market_b = get_market_bounds(id);\r\n            //console.log(market_b);\r\n        }\r\n\r\n        options.xaxis.ticks = intersects;\r\n\r\n        plot = $.plot(\"#placeholder\", [\r\n\r\n            {\r\n                data: opp_pos[0],\r\n                /*hoverable: false,*/ color: player_pos[0][2],\r\n                points: {\r\n                    show: true,\r\n                    radius: 3,\r\n                    fill: true,\r\n                    fillColor: player_pos[0][2]\r\n                }\r\n            }, {\r\n                data: opp_pos[1],\r\n                color: player_pos[1][2],\r\n                points: {\r\n                    show: true,\r\n                    radius: 3,\r\n                    fill: true,\r\n                    fillColor: player_pos[1][2]\r\n                }\r\n            }, {\r\n                data: targ_line,\r\n                color: '#000000',\r\n                lines: {\r\n                    show: true,\r\n                    fill: false\r\n                }\r\n            }, {\r\n                data: tmp,\r\n                color: tmp_col,\r\n                points: {\r\n                    show: true,\r\n                    radius: 3,\r\n                    fill: true,\r\n                    fillColor: tmp_col\r\n                }\r\n            },\r\n\r\n            {\r\n                data: tmp_a0,\r\n                hoverable: false,\r\n                color: player_color(network.players[0].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a0_front,\r\n                hoverable: false,\r\n                color: player_color(network.players[0].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a0_back,\r\n                hoverable: false,\r\n                color: player_color(network.players[0].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            },\r\n\r\n\r\n            {\r\n                data: tmp_a1,\r\n                color: player_color(network.players[1].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a1_front,\r\n                hoverable: false,\r\n                color: player_color(network.players[1].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            }, {\r\n                data: tmp_a1_back,\r\n                hoverable: false,\r\n                color: player_color(network.players[1].id),\r\n                lines: {\r\n                    show: true\r\n                }\r\n            },\r\n\r\n\r\n            {\r\n                data: my_pos,\r\n                color: '#000000',\r\n                points: {\r\n                    show: true,\r\n                    radius: 5,\r\n                    fill: true,\r\n                    fillColor: '#0099FF'\r\n                }\r\n            }, {\r\n                data: market_b,\r\n                color: col,\r\n                lines: {\r\n                    show: true,\r\n                    fill: 0.25\r\n                }\r\n            }\r\n\r\n        ], options);\r\n    }\r\n\r\n    var date = 0;\r\n    var old_date = 0;\r\n\r\n    /*\r\n     * rewdraw and update flow payoff plot\r\n     */\r\n    function update_plot2() {\r\n            if (waiting) return;\r\n\r\n            if (game_type == \"continuous\") {\r\n                //make sure everyone is sorted\r\n                sort_players();\r\n                find_intersect_pts();\r\n\r\n                //so we can get the correct payoffs\r\n                // var index = get_index_by_id(id);\r\n                // var pay = payoff(index);\r\n                // rs.send(\"update_payoff\", {\r\n                //     pay: pay,\r\n                //     index: index\r\n                // });\r\n\r\n                //let's find how long it was since we updated our payoffs      \r\n                date = new Date();\r\n                date.getTime();\r\n\r\n                var d = date - old_date;\r\n                old_date = date;\r\n\r\n                p2_t += 0.12;\r\n                // p2_t += d;\r\n\r\n                cummulative_payoff += network.players[get_index_by_id(id)].payoff * (d / (period_length * 1000));\r\n\r\n                document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n\r\n                if (flow_opts == \"all\") {\r\n                    //push all player's data to be plotted\r\n                    flow_payoff.push([p2_t, network.players[get_index_by_id(in_group[0])].payoff]);\r\n                    flow_payoff2.push([p2_t, network.players[get_index_by_id(in_group[1])].payoff]);\r\n\r\n                    total_flow.push([p2_t, network.players[get_index_by_id(in_group[0])].payoff]);\r\n                    total_flow2.push([p2_t, network.players[get_index_by_id(in_group[1])].payoff]);\r\n\r\n                    //add extra white space to front of plot to hide end time\r\n                    p2_options.xaxis.max = flow_payoff[flow_payoff.length - 1][0] + 5;\r\n\r\n                    last_20.push(network.players[get_index_by_id(in_group[0])].payoff);\r\n                    last_20.push(network.players[get_index_by_id(in_group[1])].payoff);\r\n\r\n                    //get rid of data more than 20seconds old\r\n                    if (time >= 20) {\r\n                        flow_payoff.shift();\r\n                        flow_payoff2.shift();\r\n                        last_20.shift();\r\n                        p2_options.xaxis.min = flow_payoff[0][0];\r\n                    }\r\n\r\n                    //scale flow payoff y axis to fit m ax payoff during the last 20 seconds \r\n                    p2_options.yaxis.max = Math.max.apply(null, last_20) * 1.1;\r\n\r\n                    plot2 = $.plot(\"#placeholder2\", [{\r\n                        data: flow_payoff,\r\n                        color: player_color(network.players[get_index_by_id(in_group[0])].id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        }\r\n                    }, {\r\n                        data: flow_payoff2,\r\n                        color: player_color(network.players[get_index_by_id(in_group[1])].id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        }\r\n                    }], p2_options);\r\n\r\n                } else if (flow_opts == \"own\") {\r\n                    //in this case we only plot our own payoff data\r\n                    flow_payoff.push([p2_t, network.players[get_index_by_id(id)].payoff]);\r\n                    total_flow.push([p2_t, network.players[0].payoff]);\r\n\r\n                    last_20.push(network.players[get_index_by_id(id)].payoff);\r\n                    p2_options.xaxis.max = flow_payoff[flow_payoff.length - 1][0] + 5;\r\n\r\n                    if (time >= 20) {\r\n                        flow_payoff.shift();\r\n                        last_20.shift();\r\n                        p2_options.xaxis.min = flow_payoff[0][0];\r\n                    }\r\n\r\n                    p2_options.yaxis.max = Math.max.apply(null, last_20) * 1.1;\r\n\r\n                    plot2 = $.plot(\"#placeholder2\", [{\r\n                        data: flow_payoff,\r\n                        color: player_color(id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        }\r\n                    }], p2_options);\r\n\r\n                } else if (flow_opts == \"none\") {\r\n                    //otherwise we plot nothing\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                //else we are in discrete time\r\n                p2_options.xaxis.tickDecimals = 0;\r\n                p2_options.xaxis.min = 0;\r\n                p2_options.xaxis.max = curr_subperiods + 2;\r\n                p2_options.xaxis.ticks = p2_ticks;\r\n\r\n                if (flow_opts == \"all\") {\r\n                    flow_payoff = plot_data(sub_pay[0], 0, 1);\r\n                    flow_payoff2 = plot_data(sub_pay[1], 0, 1);\r\n\r\n                    //set player's payoff bar graphs to have 25% opacity\r\n                    if (network.players[0].id == id) filler = [0.25, 0];\r\n                    else if (network.players[1].id == id) filler = [0, 0.25];\r\n\r\n                    plot2 = $.plot(\"#placeholder2\", [{\r\n                        data: flow_payoff,\r\n                        color: player_color(network.players[0].id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        },\r\n                        lines: {\r\n                            fill: filler[0]\r\n                        }\r\n                    }, {\r\n                        data: flow_payoff2,\r\n                        color: player_color(network.players[1].id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        },\r\n                        lines: {\r\n                            fill: filler[1]\r\n                        }\r\n                    }], p2_options);\r\n                } else if (flow_opts == \"own\") {\r\n\r\n                    flow_payoff = plot_data(sub_pay[get_index_by_id(id)], 0, 1);\r\n\r\n                    plot2 = $.plot(\"#placeholder2\", [{\r\n                        data: flow_payoff,\r\n                        color: player_color(id),\r\n                        points: {\r\n                            show: false,\r\n                            radius: 4,\r\n                            fill: true,\r\n                            fillColor: '#C7C7C7'\r\n                        },\r\n                        lines: {\r\n                            fill: 0.25\r\n                        }\r\n                    }], p2_options);\r\n                    return;\r\n                } else {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        /*\r\n         * nicely package flow payoff data for discrete time types\r\n         * div is now always 1 since lines should overlap\r\n         */\r\n    function plot_data(input, offset, div) {\r\n        var res = [];\r\n        var i = 0;\r\n        p2_ticks = [];\r\n        for (var a in input) {\r\n            if (input[a] !== 0) {\r\n                res.push([i + ((1 / div) * offset), null]);\r\n                res.push([i + ((1 / div) * offset), input[a]]);\r\n                res.push([i + ((1 / div) * (offset + 1)), input[a]]);\r\n                res.push([i + ((1 / div) * (offset + 1)), null]);\r\n                p2_ticks.push(i);\r\n                i++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function updatePayoffPipeline() {\r\n        sort_players();\r\n        find_intersect_pts();\r\n        var index = get_index_by_id(id);\r\n\r\n        //rs.send(\"update_bounds\", { index:index, new_lo_bound:new_lo_bound, new_hi_bound:new_hi_bound } );\r\n\r\n        var pay = payoff(index);\r\n        rs.send(\"update_payoff\", {\r\n            pay: pay,\r\n            index: index\r\n        });\r\n        rs.trigger(\"update_my_payoff\", {\r\n            pay: pay,\r\n            index: index\r\n        });\r\n    }\r\n\r\n    /*\r\n     * payoff debug \"V\" generating function\r\n     */\r\n    function a(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n        // x-l^2+p\r\n\r\n        for (var x = 0; x <= 1; x = x + 0.01) {\r\n            var y = p + Math.abs(l + x);\r\n\r\n            res.push([x, y]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function a_mirror(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n        for (var x = player.loc; x <= 5; x = x + 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.abs(l + x);\r\n\r\n            if (curr_loc > 1) {\r\n                curr_loc = 0 + Math.abs(1 - x);\r\n                if (index == 0) {\r\n                    tmp_a0_back.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_back.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n\r\n        for (var x = player.loc; x >= -5; x = x - 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.abs(l + x);\r\n\r\n            if (curr_loc < 0) {\r\n                curr_loc = Math.abs(1 + x);\r\n                if (index == 0) {\r\n                    tmp_a0_front.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_front.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function quad(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n\r\n        for (var x = 0; x <= 1; x = x + 0.01) {\r\n\r\n            var y = p + Math.pow(Math.abs(l + x), 2);\r\n\r\n            res.push([x, y]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function quad_mirror(index) {\r\n        var res = [];\r\n        var player = network.players[index];\r\n        if (player === null || player === undefined) return;\r\n\r\n        var l = player.loc * -1;\r\n        var p = player.price;\r\n\r\n        for (var x = player.loc; x <= 5; x = x + 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.pow(Math.abs(l + x), 2);\r\n\r\n            if (curr_loc > 1) {\r\n                curr_loc = 0 + Math.abs(1 - x);\r\n                if (index == 0) {\r\n                    tmp_a0_back.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_back.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n\r\n        for (var x = player.loc; x >= -5; x = x - 0.001) {\r\n            var curr_loc = x;\r\n            var y = p + Math.pow(Math.abs(l + x), 2);\r\n\r\n            if (curr_loc < 0) {\r\n                curr_loc = Math.abs(1 + x);\r\n                if (index == 0) {\r\n                    tmp_a0_front.push([curr_loc, y]);\r\n                } else if (index == 1) {\r\n                    tmp_a1_front.push([curr_loc, y]);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            res.push([curr_loc, y]);\r\n        }\r\n\r\n\r\n        return res;\r\n    }\r\n\r\n\r\n    /*\r\n     * default\r\n     */\r\n    function linear_cost() {\r\n        var res = [];\r\n        var pos = get_index_by_id(id);\r\n\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            if (i != pos) res.push(Math.abs(network.players[pos].loc - network.players[i].loc) * t);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * d^2 * t\r\n     */\r\n    function quadratic_cost() {\r\n        var res = [];\r\n        var pos = get_index_by_id(id);\r\n\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            if (i != pos) res.push(Math.abs(Math.pow(network.players[pos].loc - network.players[i].loc), 2) * t);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * find only players that have a market share\r\n     */\r\n    function validate_players() {\r\n        var tmp = network.players;\r\n        var res = [];\r\n        //var index;\r\n        var i;\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            var p1 = network.players[i];\r\n            tmp[i].valid = 1;\r\n\r\n            for (var j = 0; j < network.players.length; ++j) {\r\n                var p2 = network.players[j];\r\n\r\n                //for every player excluding yourself compare price\r\n                if (i != j) {\r\n                    if (linear) {\r\n\r\n                        if (p1.price > p2.price + t * Math.abs(p1.loc - p2.loc)) {\r\n                            tmp[i].valid = 0;\r\n\r\n                            //update player's new market bounds\r\n                            var new_lo_bound = 0;\r\n                            var new_hi_bound = 0;\r\n\r\n                            network.players[i].bound_lo = new_lo_bound;\r\n                            network.players[i].bound_hi = new_hi_bound;\r\n                        }\r\n                    } else if (quadratic) {\r\n                        var intersection = (Math.pow(p1.loc, 2) - Math.pow(p2.loc, 2) + p1.price - p2.price) / (2 * Math.abs(p1.loc - p2.loc));\r\n                        intersection = Math.abs(intersection);\r\n\r\n                        var priceScalar = p2.price + t * Math.pow(p1.loc - p2.loc, 2);\r\n\r\n                        //If the intersection occurs less than 0 or above 1, the player with the lower price `wins`\r\n                        if (!((0 < intersection) && (intersection < 1))) {\r\n\r\n                            if (p1.price > p2.price) {\r\n                                tmp[i].valid = 0;\r\n\r\n                                //update player's new market bounds\r\n                                var new_lo_bound = 0;\r\n                                var new_hi_bound = 0;\r\n\r\n                                network.players[i].bound_lo = new_lo_bound;\r\n                                network.players[i].bound_hi = new_hi_bound;\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            if (tmp[i].valid == 1) res.push(network.players[i]);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * returns array of all points along x-axis that correspond to an intersection\r\n     */\r\n    function find_intersect_pts() {\r\n        var res = [];\r\n        res.push(0);\r\n\r\n        var tmp = validate_players();\r\n        var i;\r\n\r\n        // t(lH)+(pH)+t(lL)-(pL)2t\r\n        // t(lH+lL) + (pH-pL)\r\n\r\n        //high = [i+1], low = [i]\r\n        if (linear) {\r\n\r\n            for (i = 0; i < tmp.length - 1; ++i) {\r\n                var intersect1 = (t * (tmp[i + 1].loc + tmp[i].loc) + (tmp[i + 1].price - tmp[i].price)) / (2 * t);\r\n                res.push(intersect1);\r\n\r\n                if (payoff_mirror) {\r\n                    var diff = Math.abs(tmp[i].loc - tmp[i + 1].loc);\r\n                    var intersect2 = tmp[i].loc + diff;\r\n\r\n                    res.push(intersect2);\r\n                }\r\n                //console.log (res);\r\n            }\r\n\r\n\r\n\r\n        } else if (quad) {\r\n            for (i = 0; i < tmp.length - 1; ++i) {\r\n\r\n                //Let's recreate the lower player on the left and right side of the boundaries\r\n                if (payoff_mirror) {\r\n                    var loc_low_one = tmp[i].loc + 1;\r\n                    var loc_low_zero = tmp[i].loc - 1;\r\n                }\r\n                var loc_low = tmp[i].loc;\r\n                var price_low = tmp[i].price;\r\n                var loc_high = tmp[i + 1].loc;\r\n                var price_high = tmp[i + 1].price\r\n\r\n                //this calculates the intersections between two quadratics\r\n                var top = (Math.pow(loc_high, 2) - Math.pow(loc_low, 2) + price_high - price_low);\r\n                var denom = (2 * Math.abs(loc_high - loc_low));\r\n                var intersection = top / denom;\r\n\r\n                //grab our inital intersection\r\n                if (intersection < 0 || intersection > 1) {\r\n                    res.push(0);\r\n                } else {\r\n                    res.push(intersection);\r\n                }\r\n                //lets grab our mirrored intersections\r\n                if (payoff_mirror) {\r\n                    //this calculates the intersections between two quadratics, one with the compared player and one with the player mirrored above 1\r\n                    var top = (Math.pow(loc_high, 2) - Math.pow(loc_low_one, 2) + price_high - price_low);\r\n                    var denom = (2 * Math.abs(loc_high - loc_low_one));\r\n                    var intersection = top / denom;\r\n\r\n                    //grab our intersection\r\n                    if (intersection < 0 || intersection > 1) {\r\n                        res.push(0);\r\n                    } else {\r\n                        res.push(intersection);\r\n                    }\r\n\r\n                    //this calculates the intersections between two quadratics, one with the compared player and one with the player mirrored below 0\r\n                    var top = (Math.pow(loc_high, 2) - Math.pow(loc_low_zero, 2) + price_high - price_low);\r\n                    var denom = (2 * Math.abs(loc_high - loc_low_zero));\r\n                    var intersection = top / denom;\r\n\r\n                    //grab our intersection\r\n                    if (intersection < 0 || intersection > 1) {\r\n                        res.push(0);\r\n                    } else {\r\n                        res.push(intersection);\r\n                    }\r\n\r\n\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        res.push(1);\r\n        //console.log(\"intersections between valid players at: \" + res);\r\n        var new_lo_bound;\r\n        var new_hi_bound;\r\n        var index;\r\n\r\n        /*causing issues of mis-synchronization of market boundaries by not passing over new values*/\r\n        /*now ever subject clicking recalculates the new market bounds for everyone, not just the syncronizer (keeper) - lines 456 and 467*/\r\n        //if(id == keeper){\r\n        for (i = 0; i < tmp.length; ++i) {\r\n            new_lo_bound = res[i];\r\n            new_hi_bound = res[i + 1];\r\n            index = get_index_by_id(tmp[i].id);\r\n\r\n            network.players[index].bound_lo = new_lo_bound;\r\n            network.players[index].bound_hi = new_hi_bound;\r\n\r\n            //line below did not exist before the fix..\r\n            rs.send(\"update_bounds\", {\r\n                index: index,\r\n                new_lo_bound: new_lo_bound,\r\n                new_hi_bound: new_hi_bound\r\n            });\r\n        }\r\n\r\n        //}\r\n\r\n        return res;\r\n    }\r\n\r\n    /*\r\n     * payoff = market_share * price\r\n     */\r\n    function payoff(index) {\r\n        var market_share = Math.abs(network.players[index].bound_hi - network.players[index].bound_lo) * scalar_x;\r\n        return market_share * (network.players[index].price * scalar_y);\r\n    }\r\n\r\n    /*\r\n     * sorts players in descending order. bubblesort\r\n     */\r\n    function sort_players() {\r\n        var grp = network.players;\r\n        var len = network.players.length;\r\n\r\n        for (var i = 0; i < len - 1; ++i) {\r\n            for (var j = 0; j < ((len - 1) - i); ++j) {\r\n                if (grp[j].loc > grp[j + 1].loc) {\r\n                    var tmp = grp[j + 1];\r\n                    grp[j + 1] = grp[j];\r\n                    grp[j] = tmp;\r\n                }\r\n            }\r\n        }\r\n\r\n        network.players = grp;\r\n    }\r\n\r\n    /*\r\n     * returns index in network object array of player with id 'key'\r\n     */\r\n    function get_index_by_id(key) {\r\n        var res = -1;\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            if (network.players[i].id == key) return i;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    function get_players() {\r\n        //if(waiting) return;\r\n        if (id == keeper) {\r\n            var value = network.players;\r\n            rs.send(\"data_log\", {\r\n                value: value,\r\n                curr_subperiods: curr_subperiods,\r\n                silo_num: silo_num\r\n            });\r\n        }\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            player_pos[i] = [network.players[i].loc, network.players[i].price, network.players[i].color];\r\n        }\r\n    }\r\n\r\n    function log_data() {\r\n            if (id == keeper && !waiting) {\r\n                var value = network.players;\r\n                rs.send(\"data_log\", {\r\n                    value: value,\r\n                    curr_subperiods: curr_subperiods,\r\n                    silo_num: silo_num\r\n                });\r\n            }\r\n        }\r\n\r\n    //time keeping 1s interval function\r\n    function tick() {\r\n        if (waiting) return;\r\n\r\n        if (time <= 1) {\r\n            $(\".period\").HTML = \"Period: \" + rs.period;\r\n            network.players[get_index_by_id(id)].color = col;\r\n        }\r\n\r\n        // generate random player clicks if debug option is set\r\n        if (r_debug) {\r\n            new_loc = Math.random().toFixed(3);\r\n            new_pos = Math.random().toFixed(3);\r\n            var iterx = 0;\r\n            var itery = 0;\r\n            rs.send(\"update_loc\", {\r\n                new_loc: new_loc,\r\n                id: id,\r\n                iterx: iterx\r\n            });\r\n            rs.send(\"update_pos\", {\r\n                new_pos: new_pos,\r\n                id: id,\r\n                itery: itery\r\n            });\r\n\r\n            target_pos = [Number(new_loc), Number(new_pos)];\r\n            rs.send(\"update_target\", {\r\n                new_loc: new_loc,\r\n                new_pos: new_pos,\r\n                id: id\r\n            });\r\n        }\r\n\r\n        time = time + 1;\r\n\r\n        // hope to fix any weird color overriding at start... \r\n        if (time == 5) {\r\n            for (var n in network.players) {\r\n                if (network.players[n].color == '#0066FF' && network.players[n].id != id)\r\n                    network.players[n].color = colors[1];\r\n            }\r\n        }\r\n\r\n        if (game_type == \"stage\") {\r\n            var width = ((100 / (period_length / subperiods)) * time) % 100;\r\n            $('#progBar').css('width', width + \"%\");\r\n        } else {\r\n            var width = (100 / period_length) * time;\r\n            $('#progBar').css('width', width + \"%\");\r\n        }\r\n\r\n        if (id == keeper) rs.send(\"sync_time\", {\r\n            time: time\r\n        });\r\n\r\n        //  deleted because this is a duplicate functionality with the stopwatch. It lead to a problem:\r\n        //  if my page finished earlier than my partner's, this code will force the partner's to end, but not mine.\r\n        //  //check for end of period in continous time\r\n        // if (time >= period_length) {\r\n        //     console.log(\"new_period --- from line 1014\");\r\n        //     // if (id == keeper) {\r\n        //         rs.send(\"new_period\", {\r\n        //             current_period: current_period\r\n        //         });\r\n        //         console.log(\"I probably new_period from line 1014\");\r\n        //     // }\r\n        // }\r\n\r\n        if (game_type == \"simultaneous\") {\r\n            sub_pay[0][curr_subperiods - 1] = network.players[0].payoff.toFixed(2);\r\n            sub_pay[1][curr_subperiods - 1] = network.players[1].payoff.toFixed(2);\r\n\r\n            cummulative_payoff = 0;\r\n            for (i = 0; i < sub_pay[get_index_by_id(id)].length; ++i) {\r\n                cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n            }\r\n\r\n            if (time % (period_length / subperiods) === 0) {\r\n                var iterx = 0;\r\n                var itery = 0;\r\n                rs.send(\"update_loc\", {\r\n                    new_loc: new_loc,\r\n                    id: id,\r\n                    iterx: iterx\r\n                });\r\n                rs.send(\"update_pos\", {\r\n                    new_pos: new_pos,\r\n                    id: id,\r\n                    itery: itery\r\n                });\r\n\r\n                if (id == keeper) {\r\n                    rs.send(\"new_subperiod\", {\r\n                        curr_subperiods: curr_subperiods\r\n                    });\r\n\r\n                    if (curr_subperiods == subperiods) rs.send(\"new_period\", {\r\n                        current_period: current_period\r\n                    });\r\n                }\r\n\r\n            }\r\n        } else if (game_type == \"stage\") {\r\n\r\n            if (allow_x && !allow_y) document.getElementById(\"select\").innerHTML = \"Choose x\";\r\n            else if (!allow_x && allow_y) document.getElementById(\"select\").innerHTML = \"Choose y\";\r\n\r\n            if (allow_x && !flag) { //reset price at beginning of new subgame and keep old location\r\n                //new_pos = 0;\r\n                var iterx = 0;\r\n                var itery = 0;\r\n                rs.send(\"update_pos\", {\r\n                    new_pos: new_pos,\r\n                    id: id,\r\n                    itery: itery\r\n                });\r\n                flag = 1;\r\n            }\r\n\r\n            if (time % (period_length / subperiods) < 1) { //at the end of every subperiod update new position on plot\r\n                console.log(\"ENDING SUBPERIOD\");\r\n                curr_i += 4;\r\n                var iterx = 0;\r\n                var itery = 0;\r\n                var offset = 1 / num_of_players;\r\n\r\n                if (allow_x) {\r\n\r\n                    rs.send(\"update_loc\", {\r\n                        new_loc: new_loc,\r\n                        id: id,\r\n                        iterx: iterx\r\n                    });\r\n                    allow_x = 0;\r\n                    allow_y = 1; //switch to price subrounds\r\n\r\n                } else if (allow_y) {\r\n                    rs.send(\"update_pos\", {\r\n                        new_pos: new_pos,\r\n                        id: id,\r\n                        itery: itery\r\n                    });\r\n\r\n                    ++curr_sub_y;\r\n\r\n                    if (curr_sub_y == price_subrounds) { //when we reach the last price subround, start a new subgame\r\n                        if (id == keeper) rs.send(\"set_payoffs\", {\r\n                            curr_subperiods: curr_subperiods,\r\n                            id: id\r\n                        });\r\n                        sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n                        sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n\r\n                        allow_x = 1;\r\n                        allow_y = 0;\r\n\r\n                        if (id == keeper) rs.send(\"update_subsetting\", {\r\n                            allow_x: allow_x,\r\n                            allow_y: allow_y,\r\n                            curr_sub_y: curr_sub_y\r\n                        });\r\n\r\n                    }\r\n\r\n                    if (curr_sub_y == 2) {\r\n                        sub_pay[0].shift();\r\n                        sub_pay[1].shift();\r\n                    }\r\n                }\r\n\r\n                if (id == keeper) rs.send(\"new_subperiod\", {\r\n                    curr_subperiods: curr_subperiods\r\n                });\r\n\r\n                if (curr_subperiods == subperiods) { //when we go through all subperiods, it's time for a new period\r\n                    sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n                    sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n                    if (id == keeper) rs.send(\"new_period\", {\r\n                        current_period: current_period\r\n                    });\r\n                }\r\n\r\n                if (id == keeper) {\r\n                    rs.send(\"update_subsetting\", {\r\n                        allow_x: allow_x,\r\n                        allow_y: allow_y,\r\n                        curr_sub_y: curr_sub_y\r\n                    });\r\n                    rs.send(\"set_payoffs\", {\r\n                        curr_subperiods: curr_subperiods,\r\n                        id: id\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        var i;\r\n\r\n        intersects = find_intersect_pts();\r\n\r\n        //document.getElementById(\"total_score\").innerHTML = \"Total Score: \" + rs.points.toFixed(3);\r\n        //document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n\r\n        //save payoff at end of round\r\n        if (sub_pay[0][curr_subperiods - 1] === undefined) {\r\n            sub_pay[0][curr_subperiods - 1] = payoff(0).toFixed(3);\r\n        }\r\n\r\n        if (sub_pay[1][curr_subperiods - 1] === undefined) {\r\n            sub_pay[1][curr_subperiods - 1] = payoff(1).toFixed(3);\r\n        }\r\n\r\n        if (rs.config.show_secs_left) document.getElementById(\"time\").innerHTML = \"Time left: \" + Math.ceil(period_length - time) + \" Time past: \" + time;\r\n    }\r\n\r\n    /*\r\n     * function for implementing % change on x and y axes. determines if dot should continue moving or not\r\n     */\r\n    function refresh() {\r\n        if (waiting) return;\r\n\r\n        var index = get_index_by_id(id);\r\n\r\n        if ((x_rate === 0 && y_rate === 0) || game_type == \"simultaneous\" || game_type == \"stage\") {\r\n            return;\r\n        }\r\n\r\n        var iterx;\r\n        var itery;\r\n        var diffx;\r\n        var diffy;\r\n        var signx;\r\n        var signy;\r\n        var scalex;\r\n        var scaley;\r\n\r\n        if (network.players[index].loc != network.players[index].target[0]) { //while we are not at our target x position\r\n            //get difference along x\r\n            diffx = Number(network.players[index].target[0]) - Number(network.players[index].loc);\r\n\r\n            if (diffx < 0) signx = 1;\r\n            else signx = 0;\r\n\r\n            scalex = x_rate * 0.0833333;\r\n\r\n            //if we are close enough, snap into place to avoid overshoot\r\n            if (Math.abs(diffx) < (scalex * 2)) {\r\n                new_loc = Number(network.players[index].target[0]);\r\n            } else {\r\n                //otherwise keep moving player along\r\n                iterx = network.players[index].iterx - 1;\r\n                if (iterx < 0) iterx = Number(0);\r\n\r\n                //check which direction we have to move in\r\n                if (signx) new_loc = Number(network.players[index].loc) - scalex;\r\n                else new_loc = Number(network.players[index].loc) + scalex;\r\n            }\r\n\r\n            if (new_loc > 1) new_loc = 1;\r\n            else if (new_loc < 0) new_loc = 0;\r\n\r\n            rs.send(\"update_loc\", {\r\n                new_loc: new_loc,\r\n                id: id,\r\n                iterx: iterx\r\n            });\r\n        }\r\n\r\n        if (network.players[index].pos != network.players[index].target[1]) { //while we are not at our target y position\r\n            //get difference along y\r\n            diffy = Number(network.players[index].target[1]) - Number(network.players[index].price);\r\n\r\n            if (diffy < 0) signy = 1;\r\n            else signy = 0;\r\n\r\n            scaley = y_rate * 0.0833333;\r\n\r\n            //if we are close enough, snap into place to avoid overshoot\r\n            if (Math.abs(diffy) < (scaley * 2)) {\r\n                new_pos = Number(network.players[index].target[1]);\r\n            } else {\r\n                //otherwise keep moving player along\r\n                itery = network.players[index].itery - 1;\r\n                if (itery < 0) itery = Number(0);\r\n\r\n                if (signy) new_pos = Number(network.players[index].price) - scaley;\r\n                else new_pos = Number(network.players[index].price) + scaley;\r\n            }\r\n\r\n            if (new_loc > 1) new_pos = 1;\r\n            else if (new_loc < 0) new_pos = 0;\r\n\r\n            if (new_pos > 1) new_pos = 1;\r\n            if (new_pos < 0) new_pos = 0;\r\n\r\n            rs.send(\"update_pos\", {\r\n                new_pos: new_pos,\r\n                id: id,\r\n                itery: itery\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    rs.on_load(function() {\r\n\r\n        rs.send(\"config\", {});\r\n        period_length = rs.config.period_length;\r\n\r\n        id = rs.user_id;\r\n        group_num = rs._group;\r\n        console.log(\"group_num\", group_num);\r\n\r\n        for (var i = 0, l = rs.subjects.length; i < l; i++) {\r\n            in_group.push(parseInt(rs.subjects[i].user_id));\r\n        }\r\n        num_of_bidders = rs.subjects.length;\r\n        num_of_players = in_group.length;\r\n\r\n        current_period = rs.period;\r\n        time = 0;\r\n        network.players = [];\r\n        if (rs.config.subperiods != 0) game_type = rs.config.discrete_time_type;\r\n\r\n        $scope.clock = SynchronizedStopWatch.instance()\r\n            .frequency(1).onTick(tick)\r\n            .duration(period_length)\r\n            .onComplete(function() {\r\n                rs.send(\"new_period\", {\r\n                    current_period: current_period\r\n                });\r\n            });\r\n\r\n        $scope.clock.start();\r\n        \r\n\r\n        setInterval(refresh, 30);\r\n        setInterval(log_data, 10);\r\n        setInterval(update_plot2, 120);\r\n        setInterval(update_plot, 60);\r\n\r\n        //initialize our player objects\r\n        for (var i = 0; i < num_of_players; ++i) {\r\n            var player = {};\r\n            player.loc = 0;\r\n            player.price = 0;\r\n            player.payoff = 0;\r\n            player.bound_lo = 0;\r\n            player.bound_hi = 0;\r\n            player.id = in_group[i];\r\n            player.valid = 1;\r\n            player.iterx = 0;\r\n            player.itery = 0;\r\n            player.target = [0, 0];\r\n            player.group = group_num;\r\n            player.color = colors[i];\r\n            network.players.push(player);\r\n        }\r\n\r\n        //prevent user input while period syncs up\r\n        $('#myModal').modal({\r\n            backdrop: 'static',\r\n            keyboard: false\r\n        });\r\n        //$(\"#myModal\").modal('show');\r\n\r\n\r\n        //plot 1 on click event handler\r\n        $(\"#placeholder\").bind(\"plotclick\", function plotclick(event, pos, item) {\r\n            if (game_type == \"stage\") {\r\n                if (allow_x) new_loc = pos.x.toFixed(3);\r\n                else if (allow_y) new_pos = pos.y.toFixed(3);\r\n            } else {\r\n                console.log(\"The click position: (\", pos.x, \",\", pos.y, \")\");\r\n                new_loc = pos.x.toFixed(3);\r\n                new_pos = pos.y.toFixed(3);\r\n            }\r\n\r\n            if (new_loc > 1) new_loc = 1;\r\n            else if (new_loc < 0) new_loc = 0;\r\n\r\n            if (new_pos > 1) new_pos = 1;\r\n            if (new_pos < 0) new_pos = 0;\r\n\r\n            //iters no longer used..\r\n            var iterx = 0;\r\n            var itery = 0;\r\n            target_pos = [Number(new_loc), Number(new_pos)];\r\n\r\n            if (game_type == \"simultaneous\" || game_type == \"stage\") {\r\n                //my_pos = [[new_loc, new_pos]];\r\n            } else if (game_type == \"continuous\") {\r\n                if (x_rate === 0) {\r\n                    rs.send(\"update_loc\", {\r\n                        new_loc: new_loc,\r\n                        id: id,\r\n                        iterx: iterx\r\n                    });\r\n                    rs.trigger(\"update_my_loc\", {\r\n                        new_loc: new_loc,\r\n                        id: id,\r\n                        iterx: iterx\r\n                    });\r\n                    network.players[get_index_by_id(id)].loc = Number(new_loc); //seems that sync is too slow. added after sending message to force change immediately.\r\n                }\r\n                if (y_rate === 0) {\r\n                    rs.send(\"update_pos\", {\r\n                        new_pos: new_pos,\r\n                        id: id,\r\n                        itery: itery\r\n                    });\r\n                    rs.trigger(\"update_my_pos\", {\r\n                        new_pos: new_pos,\r\n                        id: id,\r\n                        itery: itery\r\n                    });\r\n                    network.players[get_index_by_id(id)].price = Number(new_pos); //force change immediately. still send msg for record.\r\n                }\r\n\r\n                rs.send(\"update_target\", {\r\n                    new_loc: new_loc,\r\n                    new_pos: new_pos,\r\n                    id: id\r\n                });\r\n                rs.trigger(\"update_my_target\", {\r\n                    new_loc: new_loc,\r\n                    new_pos: new_pos,\r\n                    id: id,\r\n                });\r\n\r\n                rs.send(\"data_update_completed\");\r\n                updatePayoffPipeline();\r\n            }\r\n\r\n            update_plot();\r\n        });\r\n\r\n\r\n        //plot 1 on hover event handler for drawing crosshairs\r\n        $(\"#placeholder\").bind(\"plothover\", function plothover(event, pos, item) {\r\n            var a, b;\r\n\r\n            if (game_type == \"stage\") {\r\n                if (allow_x && !allow_y) {\r\n                    a = pos.x.toFixed(3);\r\n                } else if (!allow_x && allow_y) {\r\n                    b = pos.y.toFixed(3);\r\n                }\r\n            } else {\r\n                a = pos.x.toFixed(3);\r\n                b = pos.y.toFixed(3);\r\n            }\r\n\r\n            mouse = [a, b];\r\n\r\n            intersects[num_of_players + 1] = a;\r\n\r\n            options.xaxis.ticks = intersects;\r\n            options.yaxis.ticks = [0, b, 1.5];\r\n        });\r\n\r\n    });\r\n\r\n    rs.recv(\"rdebug\", function(uid, msg) {\r\n        r_debug = msg.mode;\r\n    });\r\n\r\n    rs.recv(\"data_log\", function(uid, msg) {\r\n        //intentionally blank    \r\n    });\r\n\r\n    rs.recv(\"set_payoffs\", function(uid, msg) {\r\n        intersects = find_intersect_pts();\r\n\r\n        for (i = 0; i < network.players.length; ++i) {\r\n            var pay = payoff(i);\r\n            var index = i;\r\n            rs.send(\"update_payoff\", {\r\n                pay: pay,\r\n                index: index\r\n            });\r\n        }\r\n    });\r\n\r\n    rs.recv(\"new_subperiod\", function(uid, msg) {\r\n        if (msg.curr_subperiods !== null) {\r\n            curr_subperiods = msg.curr_subperiods + 1;\r\n            cummulative_payoff = 0;\r\n\r\n            for (var i = 0; i < sub_pay[get_index_by_id(id)].length; ++i)\r\n                cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n\r\n            document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n        } else return;\r\n    });\r\n\r\n    rs.recv(\"new_period\", function(uid, msg) {\r\n        waiting = 1;\r\n\r\n        //count up sub payoffs for total period payoff for discrete types\r\n        if (game_type != \"continuous\") {\r\n            cummulative_payoff = 0;\r\n            for (var i = 0; i < sub_pay[get_index_by_id(id)].length; ++i)\r\n                cummulative_payoff += Number(sub_pay[get_index_by_id(id)][i]);\r\n        }\r\n\r\n        // why are there so many parameters? .set_points only accepts one: points\r\n        console.log(\"cummulative_payoff\", cummulative_payoff);\r\n        // if (paid_round) rs.set_points(cummulative_payoff);\r\n        if (paid_round) rs.set_points(cummulative_payoff, msg.current_period, id);\r\n        document.getElementById(\"curr_score\").innerHTML = \"Current score: \" + cummulative_payoff.toFixed(3);\r\n        \r\n      \r\n        $(\"#myModal\").modal('show');\r\n        rs.send(\"new_period_request\", {current_period : current_period}); //sends request to admin to move on to next period\r\n        rs.new_period_requested = true;\r\n        // rs.next_period();\r\n        \r\n    });\r\n\r\n    // if admin permitted new_period -- admin checks if everyone is finished with period -- move on to next_period\r\n    rs.recv(\"new_period_called_by_admin\", function(uid, msg) {\r\n        if (uid == \"admin\" && msg.current_period == current_period) {\r\n            rs.next_period();\r\n        }\r\n    });\r\n\r\n\r\n    rs.recv(\"update_player\", function(uid, msg) {\r\n        if (msg.id !== null) {\r\n            network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(0);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_payoff\", function(uid, msg) {\r\n        if (msg.pay !== null) {\r\n            network.players[msg.index].payoff = Number(msg.pay);\r\n        }\r\n    });\r\n\r\n    rs.on(\"update_my_payoff\", function(msg) {\r\n        if (msg.pay !== null) {\r\n            network.players[msg.index].payoff = Number(msg.pay);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_bounds\", function(uid, msg) {\r\n\r\n        if (msg.new_lo_bound !== null) {\r\n            network.players[msg.index].bound_lo = msg.new_lo_bound;\r\n        }\r\n\r\n        if (msg.new_hi_bound !== null) {\r\n            network.players[msg.index].bound_hi = msg.new_hi_bound;\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_iterx\", function(uid, msg) {\r\n        if (msg.iterx !== null) {\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.target_x - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_itery\", function(uid, msg) {\r\n        if (msg.itery !== null) {\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.target_y - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_loc\", function(uid, msg) {\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [msg.new_loc, network.players[get_index_by_id(msg.id)].price, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n    rs.on(\"update_my_loc\", function(msg) {\r\n        console.log(\"updating my location\");\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].loc = Number(msg.new_loc);\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [msg.new_loc, network.players[get_index_by_id(msg.id)].price, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n\r\n    rs.recv(\"update_pos\", function(uid, msg) {\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].price = Number(msg.new_pos);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [network.players[get_index_by_id(msg.id)].loc, msg.new_pos, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n    rs.on(\"update_my_pos\", function(msg) {\r\n        console.log(\"updating my price\");\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].price = Number(msg.new_pos);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n\r\n            player_pos[get_index_by_id(msg.id)] = [network.players[get_index_by_id(msg.id)].loc, msg.new_pos, network.players[get_index_by_id(msg.id)].color];\r\n        }\r\n    });\r\n\r\n\r\n    rs.recv(\"update_target\", function(uid, msg) {\r\n        console.log(\"recieving update target\");\r\n        if (msg.id !== null) {\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n        }\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[0] = Number(msg.new_loc);\r\n        }\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[1] = Number(msg.new_pos);\r\n        }\r\n\r\n    });\r\n    rs.on(\"update_my_target\", function(msg) {\r\n        console.log(\"updating my own target\");\r\n        if (msg.id !== null) {\r\n            network.players[get_index_by_id(msg.id)].iterx = Number(Math.abs(msg.new_loc - network.players[get_index_by_id(msg.id)].loc) / (0.025 * (x_rate / 0.5))).toFixed(3);\r\n            network.players[get_index_by_id(msg.id)].itery = Number(Math.abs(msg.new_pos - network.players[get_index_by_id(msg.id)].price) / (0.025 * (y_rate / 0.5))).toFixed(3);\r\n        }\r\n        if (msg.new_loc !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[0] = Number(msg.new_loc);\r\n        }\r\n        if (msg.new_pos !== null) {\r\n            network.players[get_index_by_id(msg.id)].target[1] = Number(msg.new_pos);\r\n        }\r\n\r\n    });\r\n\r\n    rs.recv(\"data_update_completed\", function(){\r\n        updatePayoffPipeline();\r\n    });\r\n\r\n    rs.recv(\"update_subsetting\", function(uid, msg) {\r\n        //console.log(msg);\r\n        if (msg.allow_x !== null) allow_x = msg.allow_x;\r\n        if (msg.allow_y !== null) allow_y = msg.allow_y;\r\n        if (msg.curr_sub_y !== null) curr_sub_y = msg.curr_sub_y;\r\n\r\n        if (curr_sub_y == price_subrounds) {\r\n            curr_sub_y = 0;\r\n            flag = 0;\r\n        }\r\n    });\r\n\r\n    rs.recv(\"config\", function(uid, msg) {\r\n        //assign new synchronizer\r\n        if (!chosen) keeper = in_group[Math.floor(Math.random() * in_group.length)];\r\n        chosen = true;\r\n\r\n        //set all config values\r\n        subperiods = rs.config.subperiods;\r\n        period_length = rs.config.period_length;\r\n        console.log(\"period length=\" + period_length)\r\n        t = rs.config.t;\r\n        x_rate = rs.config.percent_cpsx;\r\n        y_rate = rs.config.percent_cpsy;\r\n\r\n        if (rs.config.payoff_func === 0) {\r\n            transport_cost = linear_cost;\r\n        } else {\r\n            transport_cost = quadratic_cost;\r\n            quadratic = true;\r\n            linear = false;\r\n        }\r\n\r\n        paid_round = rs.config.paid;\r\n        if (rs.config.subperiods != 0) game_type = rs.config.discrete_time_type;\r\n\r\n        debug1 = rs.config.payoff_debug;\r\n        debug2 = rs.config.payoff_debug2;\r\n        debug3 = rs.config.payoff_debug3;\r\n\r\n        flow_opts = rs.config.p2_options;\r\n\r\n        scalar_x = rs.config.scale_x;\r\n        scalar_y = rs.config.scale_y;\r\n\r\n        price_subrounds = rs.config.num_sp_settingy;\r\n\r\n        payoff_mirror = rs.config.payoff_mirror;\r\n\r\n        rs.send(\"setup\", {\r\n            chosen: chosen,\r\n            keeper: keeper\r\n        });\r\n    });\r\n\r\n    rs.recv(\"setup\", function(uid, msg) {\r\n        if (msg.chosen !== null) chosen = msg.chosen;\r\n        if (msg.keeper !== null) keeper = msg.keeper;\r\n\r\n        if (id == keeper) {\r\n            var tmp = network.players;\r\n            rs.send(\"sync_net\", {\r\n                tmp: tmp\r\n            });\r\n            rs.send(\"sync_time\", {\r\n                time: time\r\n            });\r\n        }\r\n\r\n        col = '#0066FF'; //we always want to be blue\r\n\r\n        document.getElementById(\"color\").style.color = col;\r\n        document.getElementById(\"period\").innerHTML = \"Period: \" + rs.period;\r\n\r\n        var tmp_id = \"\";\r\n        for (var i = 0; i < id.length - 15; ++i) {\r\n            tmp_id += id[i];\r\n        }\r\n        // document.getElementById(\"subj\").innerHTML = \"Subject: \" + tmp_id;\r\n\r\n        //remove progress bar for continuous game types\r\n        if(game_type == \"continuous\") document.getElementById(\"progress\").style.visibility=\"hidden\";\r\n        if(rs.config.show_secs_left === 0) document.getElementById(\"time\").style.visibility=\"hidden\";\r\n\r\n        if (paid_round) document.getElementById(\"paid\").innerHTML = \"Scoring Period\";\r\n        else document.getElementById(\"paid\").innerHTML = \"Unpaid Practice Period\";\r\n\r\n        options = {\r\n            series: {\r\n                shadowSize: 0,\r\n                lines: {\r\n                    fill: false,\r\n                    show: false\r\n                }\r\n            },\r\n            grid: {\r\n                hoverable: true,\r\n                clickable: true\r\n            },\r\n            yaxis: {\r\n                min: 0,\r\n                max: 1,\r\n                position: \"left\",\r\n                ticks: 1,\r\n                tickDecimals: 2,\r\n                tickColor: '#858585'\r\n            },\r\n            xaxis: {\r\n                min: 0,\r\n                max: 1,\r\n                ticks: 1,\r\n                tickDecimals: 3,\r\n                tickColor: '#858585',\r\n                tickFormatter: function(val, axis) {\r\n                    return val.toFixed(axis.tickDecimals);\r\n                }\r\n            }\r\n        };\r\n\r\n        p2_options = {\r\n            series: {\r\n                shadowSize: 0,\r\n                lines: {\r\n                    fill: false,\r\n                    show: true\r\n                }\r\n            },\r\n            grid: {\r\n                hoverable: false,\r\n                clickable: false\r\n            },\r\n            yaxis: {\r\n                min: 0,\r\n                ticks: 2,\r\n                tickColor: '#858585',\r\n                position: \"right\"\r\n            },\r\n            xaxis: {\r\n                min: 0,\r\n                max: 30,\r\n                tickColor: '#858585',\r\n                ticks: 0\r\n            }\r\n        };\r\n\r\n        $(\"#myModal\").modal('hide');\r\n        waiting = 0;\r\n    });\r\n\r\n    rs.recv(\"sync_net\", function(uid, msg) {\r\n        for (var i = 0; i < network.players.length; ++i) {\r\n            network.players[i] = msg.tmp[i];\r\n        }\r\n    });\r\n\r\n    rs.recv(\"sync_time\", function(uid, msg) {\r\n        if (msg.time !== null) {\r\n            time = msg.time;\r\n        }\r\n    });\r\n\r\n    rs.recv(\"get_silo\", function(uid, msg) {\r\n        id = r.username;\r\n        if (msg.curr_silo !== null && id == msg.id && msg.id !== null) {\r\n            silo_num = msg.curr_silo;\r\n        }\r\n    });\r\n\r\n}]);"}, "model": "expecon.page", "pk": 17}, {"fields": {"experiment": 4, "html": "{% load verbatim %}\r\n<!DOCTYPE HTML>\r\n<html ng-app=\"Redwood\">\r\n\t<head>\r\n\t  {% verbatim %}\r\n\t\t<title>S{{ $root.user_id }} || Finish</title>\r\n\t\t{% endverbatim %}\r\n\t\t\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/jquery/jquery.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/bootstrap/bootstrap-3.1.1.min.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/lib/angular/angular-1.2.16.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodCore.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodHelpers.js\"></script>\r\n\t\t<script type=\"text/javascript\" src=\"{{ STATIC_URL }}framework/js/redwoodSubject.js\"></script>\r\n\t\t<link type=\"text/css\" rel=\"stylesheet\" href=\"{{ STATIC_URL }}framework/css/bootstrap-3.1.1.min.css\"></link>\r\n\t\t<script type=\"text/javascript\">\r\n\t\t\t{{ js }}\r\n\t\t</script>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t{{ css }}\r\n\t\t</style>\r\n\t</head>\r\n{% verbatim %}\r\n\t<body ng-controller=\"SubjectCtrl\">\r\n\t\t\r\n\t\t<div class=\"navbar navbar-fixed-top container\">\r\n\t\t\t<div class=\"navbar navbar-default\" style=\"margin-bottom: 0;\">\r\n\t\t\t\t<div class=\"navbar-brand\" href=\"#\">Economics Experiment</div>\r\n\t\t\t\t<ul class=\"nav navbar-nav\">\r\n\t\t\t\t\t<li class=\"active\">\r\n\t\t\t\t\t\t<a>User ID: <span>{{ $root.user_id }}</span></a>    \r\n\t\t\t\t\t</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t\r\n\t\t<div class=\"container\">\r\n\t\t\t<table class=\"table table-bordered table-condensed\">\r\n\t\t\t\t<thead>\r\n\t\t\t\t\t<tr><th>Period</th><th>Points</th><th>Earnings</th></tr>\r\n\t\t\t\t</thead>\r\n\t\t\t\t<tbody id=\"results\">\r\n\t\t\t\t\t<tr ng-repeat=\"points in pointsByPeriod track by $index\">\r\n\t\t\t\t\t\t<td>{{ $index + 1 }}</td><td>{{ points | number:2 }}</td><td>${{ points | number:2 }}</td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t\t<tr class=\"warning\">\r\n\t\t\t\t\t\t<td>Average:</td><td>{{ ($root.totalPoints / ($root.period - 1) || 0) | number:2 }}</td><td>${{ ($root.totalPoints / ($root.period - 1) || 0) | number:2 }}</td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t\t<tr class=\"success\">\r\n\t\t\t\t\t\t<td>Total:</td><td>{{ $root.totalPoints | number:2 }}</td><td>${{ $root.totalPoints | number:2 }}</td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t</tbody>\r\n\t\t\t</table>\r\n\t\t</div>\r\n\t</body>\r\n{% endverbatim %}\r\n</html>\r\n\r\n", "name": "Finish", "css": "body {\r\n  padding-top: 60px;\r\n}\r\n\r\n", "js": "Redwood.controller(\"SubjectCtrl\", [\"$rootScope\", \"$scope\", \"RedwoodSubject\", function($rootScope, $scope, rs) {\r\n\trs.on_load(function() {\r\n\t\t// $scope.pointsByPeriod = rs.subject[rs.user_id].points_by_period();\r\n\t\t$scope.pointsByPeriod = rs.subject[rs.user_id].points_by_period_silo();\r\n\t\tconsole.log($scope.pointsByPeriod.shift());\r\n\t});\r\n}]);\r\n\r\n"}, "model": "expecon.page", "pk": 18}]